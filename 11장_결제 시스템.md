# 1단계. 문제 이해 및 설계 범위 확정

### 기능 요구사항

- **대금 수신(pay-in)**: 결제 시스템이 판매자 대신 고객으로부터 대금을 수령한다.
- **대금 정산(pay-out)**: 결제 시스템이 전 세계의 판매자에게 제품 판매 대금을 송신한다.
- 신용 카드 결제 처리를 직접 처리하지는 않는다. → *결제 중계 시스템 정도..?*

### 비기능 요구사항

- **신뢰성 및 내결함성**
    - 결제 실패 시 신중한 처리가 필요하다.
- **내부 서비스(결제 시스템, 회계 시스템)와 외부 서비스(결제 서비스 제공업체) 간의 조정 프로세스**
    - 시스템 간 결제 정보가 일치하는지 비동기적으로 확인한다.

### 개략적 규모 추정

- 하루 100만건의 트랜잭션 처리 = 100만건/10^5초 = **10 TPS**
    
    → 일반적인 DB로 별 문제 없이 처리 가능한 수준이므로, 처리 대역폭 대신 결제 **트랜잭션의 정확한 처리**에 초점을 둔다.
    

# 2단계. 개략적 설계안 제시 및 동의 구하기

- 결제 흐름은 크게 **대금 수신 흐름, 대금 정산 흐름** 두 단계로 세분화된다.
    
    ex) 구매자가 주문을 하면 아마존의 은행 계좌로 돈이 들어온다. → **대금 수신 흐름**
    
    ex) 제품이 배송되고 나면 아마존 계좌에서 수수료를 제외한 잔액이 판매자의 은행 계좌로 지급된다. → **대금 정산 흐름**
    

## 대금 수신 흐름

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/eacc4838-15fd-43a2-ac1d-fd6a4a9a1d86/d3963766-b054-458d-aee5-cde483341d81/Untitled.png)

### ⚙️ 결제 서비스

- 사용자로부터 결제 이벤트를 수락하고 결제 프로세스를 조율한다.
    - AML/CFT와 같은 규정을 준수하는지, 범죄 행위의 증거가 있는지 등 위험 요소를 점검한다.
    - 위험 점검을 통과한 결제만 처리한다.
- 일반적으로 위험 확인 서비스는 복잡하고 전문적이기 때문에 써드파티를 활용한다.

### ⚙️ 결제 실행자

- 결제 서비스 공급자(PSP)를 통해 결제 주문 한 건을 실행한다.
- 하나의 결제 이벤트에는 여러 결제 주문 건이 포함될 수 있다.

### ⚙️ 결제 서비스 공급자 (PSP, Payment Service Provider)

- A 계정에서 B 계정으로 돈을 옮기는 역할을 담당한다. ex) 구매자의 신용카드에서 돈을 인출하는 역할

### ⚙️ 원장 (Ledger)

- 결제 트랜잭션에 대한 금융 기록이다.
- 원장 시스템은 전자상거래 웹사이트의 총 수익 계산, 향후 수익 예측 등 결제 후 분석에서 매우 중요한 역할을 한다.

### ⚙️ 지갑 (Wallet)

- 판매자의 계정 잔액 또는 특정 사용자가 결제한 총 금액을 기록한다.

### 요청 흐름

- 사용자가 ‘주문하기’ 버튼을 클릭하면 결제 이벤트가 생성되어 결제 서비스로 전송된다.
- 결제 서비스
    - 결제 이벤트를 DB에 저장한다.
    - 단일 이벤트에 여러 결제 건이 포함되는 경우 결제 주문마다 결제 실행자를 호출한다.
- 결제 실행자
    - 결제 주문을 DB에 저장한다.
    - 결제가 성공적으로 처리되면 지갑을 갱신하여 특정 판매자의 잔고를 기록한다.
- 지갑 서버는 갱신된 잔고 정보를 DB에 저장 후 원장을 호출한다.
- 원장 서비스는 새 원장 정보를 데이터베이스에 추가한다.

## 결제 서비스 API

- **POST /v1/payments** - 결제 이벤트 실행
    - payload
        - **buyer_info**(json)
        - **checkout_id**(string)
        - **credit_card_info**(json)
        - **payment_orders**(list): {**seller_account**, **amount**, **currency**, **payment_order_id**}
    
    <aside>
    💡 **payment_order_id**가 전역적으로 고유한 ID이다.
    
    - 타사 PSP에 결제 요청을 전송할 때 payment_order_id를 멱등키로 사용한다.)
    </aside>
    
    <aside>
    💡 **amount** 필드는 double이 아닌 string 타입이다.
    
    - double은 하드웨어에 따라 직렬화/역직렬화에 사용되는 숫자 정밀도가 달라 반올림 오류를 유발할 수 있다.
    - 숫자가 매우 클 수도, 매우 작을 수도 있다.
    
    → 따라서 전송 및 저장 시 문자열로 보관하고, 표시 및 계산 시에만 숫자로 변환해서 사용한다.
    
    </aside>
    
- **GET /v1payments/{:id}** - 단일 결제 주문의 실행 상태 반환

## 결제 서비스 데이터 모델

### 결제 시스템용 저장소 선정 시 고려할 점

- 안정성이 검증되었는가?
- 모니터링 및 데이터 탐사에 필요한 도구가 풍부하게 지원되는가?
- 숙련된 DBA를 쉽게 채용할 수 있는가?

→ 일반적으로는 ACID 트랜잭션을 지원하는 전통적인 RDB를 선호한다.

### 테이블 설계

- 결제 이벤트 테이블
    - 자세한 결제 이벤트 정보가 저장된다.
    - checkout_id(PK), buyer_info, seller_info, credit_card_info, is_payment_done
- 결제 주문 테이블
    - 각 결제 주문의 실행 상태가 저장된다.
    - payment_order_id(PK), buyer_account, amount, currency, checkout_id(FK), payment_order_status, ledger_updated, wallet_updated

<aside>
💡 결제 주문 테이블의 **checkout_id**는 외래키다.

- 한 번의 결제 행위는 하나의 결제 이벤트를 만들고, 하나의 결제 이벤트에는 여러 주문이 포함될 수 있다. (1:N)
</aside>

<aside>
💡 결제 주문 처리 중에는 판매자의 은행 계좌가 아닌, 구매자의 카드 정보만 있으면 된다.

- 구매자의 신용카드에서 금액을 공제하기 위해 타사 PSP를 호출한다.
- 이 때 판매자 대신 전자상거래 웹사이트의 은행 계좌에 이체가 이루어진다. (pay-in)
- 정산 절차가 진행되면 전자상거래 웹사이트 은행계좌에서 판매자 계좌로 금액이 이체된다.
</aside>

<aside>
💡 결제 주문 테이블의 **payment_order_status**(결제 상태)는 ENUM으로 관리한다.

- **NOT_STARTED**(초기값), **EXECUTING**(결제 실행자에 주문 전송), **SUCCESS**/**FAIL**(결제 처리자 응답)
</aside>

## 복식부기(double-entry) 원장 시스템

- 모든 결제 거래를 두 개의 별도 원장 계좌에 같은 금액으로 기록한다. (차감 / 입금)
- 복식부기 시스템에서 모든 거래 항목의 합계는 0이어야한다 (차감 + 입금 = 0)
- 디버깅에 유리하고, 일관성이 보장되는 전략이다.

## 외부 결제 페이지

- 신용 카드 정보를 내부에 저장하지 않기 위해 PSP에서 제공하는 외부 신용 카드 페이지를 사용한다.
- 우리 결제 서비스가 아니라 외부 결제 페이지가 직접 고객 카드 정보를 수집한다.

## 대금 정산 흐름

- 대금 수신 흐름과 유사하나, 한 가지가 다르다.
    - 대금 수신에서 돈의 흐름: 구매자의 신용카드 → 전자상거래 웹사이트 은행 계좌
    - 대금 정산에서 돈의 흐름: 전자상거래 웹사이트 은행 계좌 → 판매자 은행 계좌 (타사 정산 서비스 사용)

# 3단계. 상세 설계

## PSP(Payment Service Provider) 연동

- 대부분의 회사는 카드 시스템에 직접 연결하지 않고, 다음 두 가지 방법 중 하나로 PSP와 연동한다.
    - 회사가 민감한 결제 정보를 안전하게 저장할 수 있는 경우 → **API 연동**
    - 회사가 규정 및 보안 문제로 결제 정보를 저장할 수 없는 경우 → **PSP가 제공하는 외부 결제 페이지를 통해 접근 ✔️**

### 외부 결제 페이지 작동 방식

- 사용자가 ‘결제’ 버튼을 클릭하면 클라이언트는 주문 정보를 담아 결제 서비스를 호출한다.
- 결제서비스는 **결제 등록 요청(결제 금액, 통화, 만료일, 리디렉션 URL 등)**을 UUID와 함께 PSP로 보낸다.
- PSP는 결제 서비스에 **결제 토큰(PSP가 발급한 UUID)**을 반환한다.
- 결제 서비스는 토큰을 DB에 저장한 후 클라이언트는 PSP가 제공하는 **외부 결제 페이지**를 표시한다.
    
    > **✅ 외부 결제 페이지에서 필요한 정보**
    > 
    > - **PSP가 발급한 토큰**: PSP의 JS 코드는 이 토큰을 사용해 결제 요청에 대한 상세 정보를 검색한다.
    > - **리디렉션 URL**: 결제가 완료되면 호출될 웹 페이지 URL
- 사용자는 **결제 세부 정보(카드번호, 카드유효기간, 소유자명 등)**을 PSP에 입력한다.
- PSP 결제 처리가 완료되면 결제 상태를 반환하고, 리디렉션 URL이 가리키는 웹 페이지로 이동한다.
- PSP는 웹훅을 통해 비동기적으로 결제 서비스를 호출하여 결제 상태를 갱신한다.

## 조정 (Reconciliation)

- 비동기 통신에서 어떻게 정확성을 보장할 수 있을까?
    
    → 관련 서비스 간의 상태를 주기적으로 비교하여 일치하는지 확인한다. (**조정**)
    

### 발생 가능한 불일치 문제 및 해결 방안

- 어떤 유형의 문제인지 알고 있으며, 문제 해결 절차를 자동화할 수 있는 경우
    
    → 불일치 문제의 분류와 조정 작업 모두 자동화한다.
    
- 어떤 유형의 문제인지 알고 있지만, 문제 해결 절차를 자동화할 수 없는 경우
    
    → 문제를 작업 큐에 넣어두고, 사람이 수동으로 처리하게끔 한다.
    
- 분류할 수 없는 유형의 문제인 경우
    
    → 문제를 작업 큐에 넣어두고, 사람이 수동으로 조사하도록 한다.
    

## 결제 지연 처리

### 결제 요청이 평소보다 오래 걸리는 케이스

- PSP가 해당 결제 요청의 위험성이 높다고 판단하여 담당자 검토를 요구하는 경우
- 신용카드사에서 3D 인증같은 추가 보호 장치를 요구하는 경우

### PSP가 오래 걸리는 결제 요청을 처리하는 방법

- PSP는 결제가 pending 상태임을 알리는 상태 정보를 클라이언트에 반환한다.
- PSP는 대기 중인 결제의 진행 상태를 추적하고, 상태가 바뀌면 웹훅을 통해 결제 서비스에 알린다.
- 어떤 PSP는 웹훅 대신 폴링을 하기도 한다.

## 내부 서비스 간 통신

### 동기식 통신

- 동기식 통신에서 한 요청에 대한 응답을 만드는 사이클은 관련된 서비스가 많을수록 길어진다.
    - 성능 저하 및 장애 전파
    - 높은 결합도 및 낮은 확장성

### 비동기식 통신

- **단일 수신자**
    - 일반적으로 공유 메시지 큐를 사용해 구현한다.
    - 공유 메시지 큐에는 복수의 구독자가 있을 수 있으나, 처리된 메시지는 큐에서 바로 제거된다.
- **다중 수신자**
    - 소비자가 수신한 메시지는 바로 사라지지 않아서 동일한 메시지를 여러 서비스가 받아 처리할 수 있다. (Kafka)
    - 결제 시스템 구현에 적합하다. (하나의 요청이 푸시 알림 전송, 재무 보고 업데이트 등 다양한 용도에 쓰일 수 있음)

### 동기식 vs 비동기식

- 동기식 통신은 설계하기 쉬우나, 서비스의 자율성과 성능이 낮아진다.
- 비동기식 통신은 시스템 확장성과 장애 감내 능력이 뛰어나다.

→ 비즈니스 로직이 복잡하고 타사 서비스 의존성이 높은 대규모 결제 시스템에는 비동기 통신이 적절하다.

## 결제 실패 처리

### 결제 상태 추적

- 결제 주기의 모든 단계에서 결제 상태를 갱신한다. (데이터 추가만 가능한 DB 테이블에 보관한다.)
- 실패가 일어날 때마다 현재 상태를 파악하여 환불 또는 재시도 필요 여부를 결정한다.

### 재시도 큐 및 실패 메시지 큐

- **재시도 큐(retry queue)**
    - 일시적 오류 같은 재시도 가능 오류는 재시도 큐에 보낸다.
- **실패 메시지 큐(dead letter queue)**
    - 반복적으로 처리에 실패한 메시지는 여기로 보낸다.
    - 이 큐는 문제가 있는 메시지를 디버깅하고 격리하여 원인을 파악하기 위한 검사에 유용하다.

## ‘정확히 한 번(exact-once)’ 전달

### 재시도

- 재시도 매커니즘을 사용하면 **최소 한 번(at-least-once)** 실행되도록 보장이 가능하다.
- 얼마나 간격을 두고 재시도할지 정하는 것이 중요하다.
    - 즉시 재시도 / 고정 간격 / 취소
    - 증분 간격: 기다리는 시간을 특정한 양만큼 점진적으로 늘린다.
    - 지수적 백오프: 기다리는 시간을 직전 재시도 대비 두 배씩 늘린다.
    
    → 네트워크 문제가 단시간 내에 해결될 것 같지 않다면 지수적 백오프를 사용한다.
    
- 에러 코드를 반환할 때는 `Retry-After` 헤더를 붙여 보낸다.
- 재시도 시 발생할 수 있는 잠재적 문제는 **이중 결제**다.
    - 클라이언트가 결제 버튼을 두 번 중복 클릭한다. (따닥)
    - PSP에서 결제를 성공적으로 처리하였으나, 응답이 오기 전에 클라이언트가 결제를 다시 시도한다.
    
    → 이주 결제를 방지하려면 결제는 **최대 한 번(at-most-once)** 이루어져야 한다. (**멱등성**)
    

### 멱등성

- 연산을 여러 번 실행하여도 최초 실행 결과가 그대로 보존되는 특성
- 클라이언트가 같은 API 호출을 여러 번 반복해도 항상 동일한 결과가 나온다.
- 결제 요청의 멱등성을 보장하기 위해 HTTP 헤더에 `<멱등키:값>` 등의 형태로 멱등키를 추가한다.
- 재시도 시 발생할 수 있는 잠재적 문제를 멱등성으로 해결하는 방법
    - **클라이언트가 결제 버튼을 두 번 중복 클릭한다. (따닥)**
        - 동일한 멱등키로 동시에 요청을 받으면 그 가운데 하나만 처리하고, 나머지는 `429`를 반환한다.
    - **PSP에서 결제를 성공적으로 처리하였으나, 응답이 오기 전에 클라이언트가 결제를 다시 시도한다.**
        - 결제 서비스는 PSP에 비중복 난수를 전송하고, PSP는 해당 난수에 대응되는 토큰을 반환한다.
        - 클라이언트가 결제를 재시도해도 PSP로 전송되는 토큰이 같기 때문에 이중 결제로 판단한다.

## 일관성

- 분산 환경에서는 서비스 간 통신 실패로 데이터 불일치가 발생할 수 있다.
- 내부 서비스와 외부 서비스(PSP) 간의 데이터 일관성 유지하기
    - 외부 서비스가 멱등성을 지원하는 경우 결제를 재시도할 때는 같은 멱등키를 사용한다.
    - 외부 시스템이 항상 옳다고 가정할 수는 없으므로 조정 절차도 함께 진행한다.
- 데이터 복제 지연으로 인한 불일치 해결하기
    - 주 데이터베이스에서만 읽기.쓰기 연산을 처리한다. → 자원 낭비
    - 모든 사본이 항상 동기화되도록 한다. (팩석스, 래프트 같은 합의 알고리즘이나 합의 기반 분산 DB를 사용한다)

## 결제 보안

- 요청/응답 도청 → HTTPS 사용
- 데이터 변조 → 암호화 및 무결성 강화 모니터링
- 중간자 공격 → 인증서 고정과 함께 SSL 사용
- 데이터 손실 → 여러 리전에 걸친데이터베이스 복제 및 스냅샷 생성
- DDoS → 처리율 제한 및 방화벽
- 카드 도난 → tokenization(실제 카드 번호 대신 토큰을 저장하고 결제에 사용)
- 사기 → 주소 확인, 카드 확인 번호, 사용자 행동 분석 등
- PCI 규정 준수

# 4단계. 마무리

- 모니터링 대시보드 만들기
    - 특정 결제 수단의 평균 승인율은 얼마인가?
    - 서버의 CPU 사용량은 얼마인가?
- 경보
    - 비정상적인 상황일 때 슬랙, 메일 등으로 알림 보내기
- 디버깅 도구
    - 엔지니어와 고객 지원팀이 쉽게 디버깅할 수 있도록 도구 개발
- 환율, 지역, 현금 결제 대응, 구글/애플 페이 연동 등
