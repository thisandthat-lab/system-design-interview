# 7장. 호텔 예약 시스템

# 1단계. 문제 이해 및 설계 범위 확정

### 기능 요구사항

- 예약 등록/취소 기능 (이 때 10% 오버부킹 가능)
- 호텔 및 객실 정보 페이지 표시
- 객실 가격은 유동적(그 날 객실에 여유가 얼마나 있는지에 따라 변동)
- 호텔이나 객실 정보 CRUD를 지원하는 관리자 페이지 지원

### 비기능 요구사항

- 5000개 호텔에 100만 개 객실을 갖춘 호텔 체인을 위한 웹사이트 구축
- **높은 수준의 동시성:** 성수기, 대규모 이벤트 기간에는 일부 인기 호텔의 특정 객실을 예약하려는 고객이 많이 몰릴 수 있음
- **적절한 지연 시간**: 예약 시 응답 시간이 빠르면 이상적이겠지만, 예약 요청 처리에 몇 초 정도 걸리는 것은 허용됨

### 개략적 규모 추정

- 총 5,000개 호텔, 100만개 객실이 있다고 가정
- 평균적으로 객실의 70%가 사용중이고, 평균 투숙 기간은 3일이라고 가정

→ 일일 예상 예약 건수 = `100만 * 0.7 / 3 = 233,333 = **약 240,000건**`

→ 초당 예약 건수 = `240,000 / 하루에 10^5초 = **~3**` ⇒ TPS는 그다지 높지 않음

### QPS 계산하기

- 일반적으로 고객이 사용하는 플로우
    - 사용자가 호텔/객실 정보를 확인한다. (**조회 발생**)
    - 사용자가 날짜, 투숙 인원, 결제 방법 등의 상세 정보를 확인한다. (**조회 발생**)
    - 사용자가 ‘예약’ 버튼을 눌러 객실을 예약한다. (**트랜잭션 발생**)
    
    → 대략 10% 사용자가 다음 단계로 진행하고, 90%의 사용자는 최종 단계 도달 전에 흐름을 이탈한다고 가정
    
- 대략적인 QPS
    - 객실 상세 페이지 → `QPS 300`
    - 예약 상세 페이지 → `QPS 30`
    - 객실 예약 페이지 → `QPS 3`

# 2단계. 개략적인 설계안 제시 및 동의 구하기

## API 설계

### 호텔 관련 API

- **`GET` /v1/hotels/id** : 호텔의 상세 정보 반환
- **`POST` /v1/hotels** : 신규 호텔 추가(어드민용)
- **`PUT` /v1/hotels/id** : 호텔 정보 갱신(어드민용)
- **`DELETE` /v1/hotels/id** : 호텔 정보 삭제(어드민용)

### 객실 관련 API

- **`GET` /v1/hotels/:id/rooms/id** : 객실 상세 정보 반환
- **`POST` /v1/hotels/:id/rooms** : 신규 객실 추가(어드민용)
- **`PUT` /v1/hotels/:id/rooms/id** : 객실 정보 갱신(어드민용)
- **`DELETE` /v1/hotels/:id/rooms/id** : 객실 정보 삭제(어드민용)

### 예약 관련 API

- **`GET` /v1/reservations** : 로그인 사용자의 예약 이력 반환
- **`GET` /v1/reservations/id** : 특정 예약의 상세 정보 반환
- **`POST` /v1/reservations** : 신규 예약
    - params 예시
        
        ```json
        {
        	"startDate": "2021-04-28",
        	"endDate": "2021-04-30",
        	"hotelID": "245",
        	"roomId": "U123456789",
        	"reservationID": "13422445"
        }
        ```
        
        - **reservationID**는 에중 예약을 방지하고, 동일한 예약은 한 번만 생성되도록 보증하는 **멱등키**
- **`DELETE` /v1/reservations/id** : 예약 취소

## 데이터 모델

- 호텔 예약 시스템이 지원해야 하는 질의
    - 호텔 상세 정보 조회
    - 지정된 날짜 범위에 사용 가능한 객실 유형 조회
    - 예약 정보 기록
    - 예약 내역 또는 과거 예약 이력 정보 조회
    
    → **RDB**를 선택한다.
    

### RDB 선택 이유

- **RDB는 읽기 빈도가 쓰기 연산에 비해 높은 작업 흐름을 잘 지원한다.**
    - 호텔 웹사이트 방문 사용자 수 > 객실 예약하는 사용자 수 이므로 조회 빈도가 압도적으로 많다.
    - NoSQL은 대체로 쓰기 연산에 최적화되어 있고, RDB는 읽기가 압도적ㅇ니 작업 흐름을 충분히 잘 지원한다.
- **RDB는 ACID(원자성, 일관성, 격리성, 영속성)를 보장한다.**
    - 예약 시스템에서 ACID는 아주 중요하다.
    - RDB는 일반적으로 ACID 속성을 보장한다.
- **RDB를 사용하면 데이터를 쉽게 모델링할 수 있다.**
    - 비즈니스 데이터의 구조를 명확하게 표현할 수 있다.
    - 엔티티(호텔, 객실, 객실 유형) 간의 관계를 안정적으로 지원할 수 있다.

### 스키마 설계

- 호텔 서비스
    - **hotel** - hotel_id(PK), name, address, location
    - **room** - room_id(PK), room_type_id, floor, number, hotel_id, name, is_available
- 요금 서비스
    - **room_type_rate** - hotel_id(PK), date(PK), rate
- 예약 서비스
    - **reservation** - reservation_id(PK), hotel_id, room_id, start_date, end_date, **status**, guest_id
    
    > **PENDING**(결제 대기), **PAID**(결제 완료), **REFUNDED**(환불 완료), **CANCELED**(취소), **REJECTED**(승인 실패)
    
    - room_id가 있으므로 에어비앤비같은 회사에는 적합한 스키마이다.
    - 호텔의 경우 특정 객실이 아닌 특정 객실 유형을 예약하기 때문에 부적절한 스키마이다.
    > 
- 투숙객 서비스
    - **guest** - guest_id(PK), first_name, lats_name, email

## 개략적 설계안

- **MSA**로 구성한다.
![IMG_7700](https://github.com/thisandthat-lab/system-design-interview/assets/132281360/f669109e-e354-4942-960e-bb94cb9193bf)

- **공개 API 게이트웨이**
    - 처리율 제한, 인증 등의 기능을 지원하는 완전 관리형 서비스
    - 엔드포인트 기반으로 특정 서비스에 요청 전달
- **내부 API**
    - 승인된 유저만 사용 가능한 API로, VPN 등의 기술을 사용하여 외부 공격으로부터 보호
- **호텔 서비스**
    - 호텔과 객실에 대한 상세 정보 제공 (캐싱)
- **요금 서비스**
    - 객실의 요금은 해당 날짜에 호텔에 얼마나 많은 손님이 몰리느냐에 따라 달라진다.
- **예약 서비스**
    - 예약 요청을 받고 객실을 예약하는 과정 처리
    - 객실이 예약되거나 취소될 때 잔여 객실 정보 갱신
- **결제 서비스**
    - 결제가 완료되면 status를 PAID로 갱신, 실패한 경우 REJECTED로 갱신
- **호텔 관리 서비스**
    - 임박한 예약 기록 확인, 고객 객실 예약, 예약 취소 등의 기능 제공

# 3단계. 상세 설계

## 개선된 데이터 모델

### 특정 객실이 아니라 특정한 객실 유형을 예약하도록 하기

- **request parameter 변경**
    
    ```json
    {
    	"startDate": "2021-04-28",
    	"endDate": "2021-04-30",
    	"hotelID": "245",
    	"roomTypeID": "U123456789",
    	"reservationID": "13422445"
    }
    ```
    
    - AS-IS : roomID
    - TO-BE : roomTypeID
- **스키마 변경**
    - AS-IS
        - **room** - room_id(PK), room_type_id, floor, number, hotel_id, name, is_available
        - **reservation** - reservation_id(PK), hotel_id, room_id, start_date, end_date, status, guest_id
    - TO-BE
        - **room** - room_id(PK), room_type_id, floor, number, hotel_id, name, is_available
        - **room_type_inventory** - **hotel_id, room_type_id, date**, total_inventory, total_reserved
        - **reservation** - reservation_id(PK), hotel_id, room_id, start_date, end_date, status, guest_id
    - **room_type_inventory**
        - 호텔의 모든 객실 유형을 담는 테이블
        - 2년 이내의 모든 미래 날짜에 대한 가용 객실 데이터 질의 결과를 토대로 데이터를 미리 만들어둔다.
        - 시간의 흐름에 따라 새로 추가해야 하는 객실 정보는 매일 한 번씩 일괄 작업을 돌려 반영한다.
        - **total_inventory**: 총 객실 수에서 일시적으로 제외한 객실 수를 뺀 값 (실제 예약 가능한 객실 수)
        - **total_reserved**: 지정된 hotel_id, room_type_id, date에 예약된 모든 객실 수
- **데이터 저장 용량 추정**
    - 5,000개의 호텔, 각 호텔에는 20개의 객실 유형이 있다고 가정
        
        → 5,000 * 20 * 2년 * 365일 = 7,300만 개
        
        → 데이터 양이 많진 않으나 SPOF 방지, 고가용성 달성을 위해 여러 AZ에 데이터를 복제해둔다.
        

### 예약 데이터가 단일 DB에 담기에 너무 크면 어떻게 해야할까?

- 현재 및 향후 예약 데이터만 저장한다.
    - 예약 이력은 자주 접근하지 않으므로 아카이빙하거나 cold storage로 이동한다.
- 데이터베이스를 샤딩한다.
    - hotel_id를 샤딩 키로, 데이터는 hash(hotel_id % number_of_servers)로 샤딩한다.

## 동시성 문제

### 시나리오 1) 같은 사용자가 예약 버튼을 여러 번 클릭한다.

- 클라이언트 측 구현
    - 요청 전송 후 예약 버튼을 disabled 처리한다.
        
        → 사용자가 우회할 수 있기 때문에 안정적인 방법은 아니다.
        
- 멱등 API (몇 번을 호출해도 같은 결과를 내는 API)
    - 예약 API 요청에 멱등 키를 추가한다.
    - flow
        - 유저가 예약 내용 입력 후 ‘다음’ 버튼을 클릭하면 예약 주문서 생성
            - 이 때 reservation_id(멱등키)가 생성된다.
        - 유저가 예약 주문서 내용을 검토하고 예약 요청을 보낸다.
            - 이 요청에 reservation_id(멱등키)를 담아 보낸다.
            - reservation_id는 예약 테이블의 PK이므로 새로운 레코드가 생성되지 않아 이중 예약이 불가하다.

### 시나리오 2) 여러 사용자가 동시에 같은 객실에 예약 요청을 보낸다.

- **방안 1) 비관적 락**
    - 사용자가 레코드를 갱신하려고 하는 순간 즉시 락을 걸어 동시 업데이트를 방지한다.
    - 동일한 레코드를 갱신하려는 다른 사용자는 락이 해제될 때까지 기다려야 한다.
    - MySQL에서는 `SELECT … FOR UPDATE` 구문을 통해 비관적 락을 걸 수 있다.
    - 장점
        - 변경 중이거나 변경이 끝난 데이터를 갱신하는 일을 방지할 수 있따.
        - 구현이 쉽고 모든 갱신 연산을 직렬화하여 충돌을 막는다.
    - 단점
        - 여러 레코드에 락을 걸면 deadlock이 발생하기 쉽다.
        - 트랜잭션의 수명이 길거나 많은 엔티티에 관련된 경우 DB 성능에 심각한 악영향을 끼친다.
    
    → 결과적으로 권장되지 않는 방법
    
- **방안 2) 낙관적 락**
    - 여러 사용자가 동시에 같은 자원에 갱신 시도하는 것을 허용한다.
    - version number, timestamp 두 가지 방법으로 구현하며, version number가 더 권장된다.
    - flow
        - 레코드 수정 요청이 들어오면 애플리케이션이 해당 레코드의 버전 번호를 읽는다.
        - 레코드가 갱신될 때 버전 번호에 1을 더한 다음 DB에 다시 기록한다.
        - 이 때 유효성 검사를 해서 다음 버전 번호가 현재 버전 번호보다 작거나 같으면 트랜잭션을 중단한다.
    - 장점
        - 비관적 락보다 빠르다.
        - DB 자원에 락을 걸 필요가 없으며, 데이터 일관성 유지의 책임은 애플리케이션에 있다.
        - 데이터에 대한 경쟁이 치열하지 않은 상황에 적합하다.
    - 단점
        - 동시성 수준이 아주 높으면 성능이 급격하게 떨어진다.
            - 읽을 때는 여러 사용자가 데이터를 읽지만, 실제로 갱신에 성공하는 클라이언트는 하나이기 때문
            - 유저 경험 측면에서도 좋지 못함
- **방안 3) 데이터베이스 제약 조건**
    - 낙관적 락과 비슷한 방식이지만, 제약 조건을 DB에 걸어둔다.
    - 장점
        - 구현이 쉽고, 데이터에 대한 경쟁이 치열하지 않은 상황에 적합하다.
    - 단점
        - 낙관적 락의 단점과 동일하다.
        - DB 제약 조건은 애플리케이션 코드와 달라서 버전을 통제하기 어렵다.
        - DB가 변경되면 구현이 변경되어야 한다.
    
    → 호텔 예약의 경우 데이터에 대한 경쟁이 심하지 않으므로(낮은 QPS) 좋은 선택지이다.
    

## 시스템의 규모 확장

- 시스템 부하가 높아진다면 무엇이 병목이 될 지 이해하는 것이 중요햐다.
- 모든 서비스는 MSA로 분리되어 있고, 무상태 서비스이므로 서비스의 스케일링은 쉽게 가능하다.
- 데이터베이스는 단순히 서버를 늘리는 것만으로 성능 문제를 해결할 수 없다.

### 데이터베이스 샤딩

- hotel_id를 샤딩 조건으로 사용한다.
- QPS가 30,000이라고 가정했을 때 DB를 16개의 샤드로 분산하는 사례
    
    → `30,000 / 16 = 1,875QPS` 처리
    

### 캐시

- 호텔 잔여 객실 데이터는 현재, 미래의 데이터만 중요하다.
    
    → 과거 데이터는 자동으로 소멸되도록 TTL을 설정한다.
    
    → Redis는 TTL과 LRU 캐시 교체 정책을 사용하여 메모리를 최적으로 활용한다.
    
- 변경된 Flow
    - 예약 서비스 → 잔여 객실 캐시
    - 예약 서비스 → DB에 잔여 객실 수 갱신
    - DB → 잔여 객실 캐시로 데이터 비동기 갱신
- 장점
    - 읽기 질의를 캐시가 처리하므로 DB 부하가 줄고, 캐시는 메모리에서 실행되므로 빠르다.
- 단점
    - DB와 캐시 사이의 데이터 일관성 문제가 발생할 수 있다.
    - 최종적으로 DB에서 유효성 체크를 하더라도 사용자 경험에는 안 좋은 영향을 미칠 수 있다.

**🔥 DB와 캐시 사이의 데이터 일관성 문제**

- 일반적인 데이터 변경 Flow
    - 잔여 객실 수를 질의하여 충분한지 확인한다 → 캐시에서 조회
    - 잔여 객실 데이터를 갱신한다. (DB 갱신 → 캐시 갱신(비동기))
        - 애플리케이션에서 수행하거나, CDC 매커니즘을 이용한다.
        - 이 찰나의 순간 또는 갱신 과정에서 오류가 발생할 경우 데이터 일관성 문제가 발생할 수 있다.
- 예약 시도 시 최종적으로 DB에서 잔여 객실을 확인하도록 해서 문제를 해결하자! (이선좌..)

### MSA에서의 데이터 일관성 문제에 대한 해결 방안

- 지금까지 살펴본 시스템은 **하이브리드 접근법**
    - 여러 시스템에서 동일한 DB에 접근한다.
- 하지만 순수한 MSA라면 각 MSA가 독자적인 DB를 갖추고 있어야 한다.
    - 논리적으로 하나의 원자적 연산이 여러 데이터베이스에 걸쳐 실행되는 일을 피할 수 없다.
        - 하나의 트랜잭션으로 데이터 일관성을 보증하는 기법을 사용할 수 없다는 뜻이다.

- **방안 1) 2-phase commit (2PC)**
    - **2PC** : 여러 노드에 걸친 원자적 트랜잭션 실행을 보증하는 데이터베이스 프로토콜
    - 모든 노드가 성공 or 실패 둘 중 하나로 트랜잭션이 마무리되도록 보증한다.
    - blocking-protocol이므로, 한 노드에 장애가 발생하면 해당 장애가 복구될 때까지 진행이 중단된다. (성능 low)
- **방안 2) Saga Pattern**
    - 각 노드에 국지적으로 발생하는 트랜잭션을 하나로 엮은 것
    - 각각의 트랜잭션이 완료되면 다음 트랜잭션을 시작하는 트리거로 쓰일 메시지를 만들어 보낸다.
    - 어느 한 트랜잭션이라도 실패하면 그 이전 트랜잭션을 전부 되돌리는 트랜잭션들을 순차적으로 실행한다.

# 4단계. 마무리

- LGTM 🚀
