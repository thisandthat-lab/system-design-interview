# 4장. 분산 메시지 큐

## 메시지 큐를 사용하면 무엇이 좋을까?

- **결합도 완화:** 컴포넌트 사이의 강한 결합이 사라지므로, 각각을 독립적으로 갱신할 수 있다.
- **규모 확장성 개선**: producer와 comsumer 각각 독립적으로 스케일링 할 수 있다.
- **가용성 개선**: 특정 컴포넌트 장애가 발생해도 다른 컴포넌는 큐와 계속 상호작용 할 수 있다.
- **성능 개선**: 쉽게 비동기 통신을 할 수 있다.

## 유명한 분산 메시지 큐

- Apache Kafka (event streaming platform)
- Apache Pulsar (event streaming platform)
- Apache RocketMQ
- Apache RabbitMQ
- Apache ActiveMQ
- ZeroMQ

# 1단계. 문제 이해 및 설계 범위 확정

## 기능 요구사항

- 메시지는 텍스트 형태만 지원한다.
- 메시지 크기는 수 KB 수준이다.
- 하나의 메시지를 여러 consumer가 수신할 수 있어야 한다.
    - 전통적인 MQ 시스템은 하나의 consumer가 수신했다면 받은 메시지를 지워버린다.
- 메시지는 생산된 순서 그대로 소비되어야 한다.
    - 전통적인 MQ 시스템은 소비 순서를 보증하지 않는다.
- 데이터는 2주간 보관되어야 한다.
    - 전통적인 MQ 시스템은 메시지이 지속성 보관을 보증하지 않는다.
- producer와 consumer는 많을수록 좋다.
- 메시지 전달 방식은 **최대 한 번(at-most-once)**을 반드시 지원해야 한다.
    - 최소 한 번(at-least-once), 정확히 한 번(exactly once)는 사용자가 설정할 수 있도록 옵션이어야 한다.

## 비기능 요구사항

- 높은 대역폭과 낮은 latency 중 하나를 설정으로 선택 가능해야 한다.
- 규모 확장성을 고려해야 한다.
- 지속성 및 내구성이 보장되어야 한다. (데이터는 지속적으로 보관되어야 하며 여러 노드에 복제되어야 한다.)

## 전통적인 MQ의 특징 (요구사항과 다른 점)

- 메시지 보관 문제를 중요하게 다루지 않는다.
    - 메시지가 소비자에게 전달되기 충분한 기간 동안만 메모리에 보관한다.
    - 처리 용량을 넘는 메시지는 디스크에 보관되긴 하지만, 아주 낮은 수준이다.
- 전달 순서를 보존하지 않는다.
    - 메시지 생산 순서와 소비 순서가 다를 수 있다.

# 2단계. 개략적 설계안 제시 및 동의 구하기

## MQ 기본 기능

- 플로우
    - producer가 메시지를 메시지 큐에 발행한다.
    - consumer는 큐를 구독하고, 구독한 큐에 전송된 메시지를 소비한다.
- 메시지 큐는 producer와 consumer 사이의 결합을 느슨하게 하여 규모 확장성을 달성시키는 컴포넌트이다.
- 클라이언트/서버 모델 관점에서 producer와 consumer는 클라이언트, 메시지 큐는 서버 역할이다.

## 메시지 모델

### 일대일 모델 (point-to-point)

- 큐에 전송된 메시지는 하나의 소비자만 가져갈 수 있다.
- 소비자가 메시지를 가져갔다는 사실을 큐에 알리면 해당 메시지는 큐에서 삭제된다.
- 데이터 보관을 지원하지 않는다.

### 발행-구독 모델 (publish-subscribe)

- 메시지를 보내고 받을 때 **토픽**에 보내고 받게 된다.
- 토픽에 전달된 메시지는 토픽을 구독하는 모든 소비자에게 전달된다.

## 토픽, 파티션, 브로커

- 토픽에 보관되는 데이터 양이 커져서 서버 한 대로 감당하기 힘들면 어떻게 해야 할까?
    - **파티션**, 즉 샤딩 기법을 활용한다.
    - 토픽을 여러 파티션으로 분할하고, 메시지를 모든 파티션에 균등하게 나눠 보낸다.
- 파티션을 유지하는 서버는 **브로커**라고 한다.
    - 파티션을 브로커에 분산하는 것이 높은 규모 확장성을 달성하는 비결이다.
    - 토픽의 용량을 확장하고 싶다면 파티션 개수를 늘린다.
- 각 토픽 파티션은 **FIFO 큐**처럼 동작한다.
    - 같은 파티션 안에서는 메시지 순서가 유지된다.
    - 같은 키를 가진 메시지는 같은 파티션으로 보내진다.
- 토픽을 구독하는 소비자가 여럿일 경우 각 구독자는 파티션의 일부를 담당한다.
    - 이 소비자들을 해당 토픽의 **컨슈머 그룹**이라고 부른다.

## 컨슈머 그룹

- 하나의 소비자 그룹은 여러 토픽을 구독할 수 있고, 오프셋을 별도로 관리한다.
- 같은 그룹 내의 소비자는 메시지를 병렬로 소비할 수 있다.
- 데이터를 병렬로 읽으면 같은 파티션 안에 있는 메시지를 순서대로 소비할 수 없다.
    - 각 파티션의 메시지는 한 그룹 안에서 오직 하나의 컨슈머만 읽을 수 있도록 제약사항을 둔다.
    - `소비자의 수 > 파티션 수`가 되면 어떤 소비자는 데이터를 읽지 못하게 된다.

## 개략적 설계안

### 클라이언트

- producer
- consumer group

### 핵심 서비스 및 저장소

- 브로커
    - 파티션을 유지한다. (하나의 파티션은 특정 토픽에 대한 메시지의 부분 집합)
- 저장소
    - 데이터 저장소: 메시지가 보관된다.
    - 상태 저장소: 컨슈머 상태가 저장된다.
    - 메타데이터 저장소: 토픽 설정 등이 저장된다.
- 코디네이션 서비스
    - 서비스 탐색
        - 어떤 브로커가 살아있는지 알려준다.
    - 리더 선출
        - 브로커 중 하나는 컨트롤러 역할을 담당해야 한다.
        - 한 클러스터에는 반드시 활성 상태 컨트롤러가 하나 있어야 한다.
        - 이 컨트롤러가 파티션 배치를 책임진다.
    - 주로 아파치 주키퍼나 etcd가 널리 이용된다.

# 3단계. 상세 설계

- **데이터의 장기 보관 + 높은 대역폭**을 동시에 제공하기 위한 설계
    - **디스크 기반 자료 구조**를 활용한다.
        - **회전 디스크**의 높은 순차 탐색 성능과 현대적 OS가 제공하는 **적극적 디스크 캐시 전략**을 잘 이용한다.
    - 메시지의 생성으로부터 전달까지 **아무 수정 없이 전송**이 가능한 메시지 자료 구조를 설계하고 활용한다.
    - 소규모 I/O가 많으면 높은 대역폭을 지원하기 어렵기 때문에 **일괄 처리**를 우선하는 시스템을 설계한다.

---

## 데이터 저장소

- 메시지 큐의 트래픽 패턴: **순차적인 읽기/쓰기 연산**이 빈번하게 발생하고, 갱신/삭제 연산은 발생하지 않는다.

### 선택지 1) 데이터베이스

- **RDB**: 토픽별로 테이블을 만들고, 메시지는 레코드로 추가한다.
- **NoSQL**: 토픽별로 컬렉션을 만들고, 메시지는 document가 된다.

→ 읽기/쓰기 연산이 모두 대규모로 빈번하게 발생하는 상황을 모두 잘 대처하는 DB는 설계하기 어렵다.

### 선택지 2) 쓰기 우선 로그(Write-Ahead Log, WAL) 👑

- WAL은 새로운 항목이 추가되기만 하는(append-only) 일반 파일이다.
    - MySQL 복구 로그, 아파치 주기퍼에서 사용
- 지속성을 보장해야 하는 메시지는 디스크에 WAL로 보관할 것을 추천한다.
    - WAL에 대한 접근 패턴은 읽기/쓰기 전부 순차적이라서, 접근 패턴이 순차적일 때 좋은 성능을 보인다.
    - 회전식 디스크 기반 저장장치는 큰 용량을 저렴한 가격에 제공한다.
- 파일의 크기가 무한정 커질 수는 없으니, 세그먼트 단위로 파일을 나누는 것이 바람직하다.
    - 새 메시지는 활성 상태의 세그먼트 파일에만 추가된다.
    - 비활성 세그먼트는 읽기 요청만 처리한다.
    - 보관 기한이 만료되거나 용량 한계에 도달하면 해당 세그먼트는 삭제한다.
    - `토픽 > 파티션 > 세그먼트` 구조로 이루어진다.

### 디스크 성능 관련 유의사항

- 데이터를 장기 보관해야 하므로, 디스크 드라이브에 데이터를 보관한다.
- 회전식 디스크가 정말 느릴까?
    - 데이터 접근 패턴이 랜덤일 때 회전식 디스크가 느려진다.
    - 순차적 데이터 접근 패턴을 활용하는 자료 구조를 사용하면 성능이 좋다.
    - 또한 현대 OS는 디스크 데이터를 메모리에 적극 캐시하기 때문에 성능이 좋다.

---

## 메시지 자료 구조

- 메시지 생산-전달 과정에서 불필요한 복사가 일어나지 않도록 함으로써 높은 대역폭을 달성한다.

## 메시지 자료 구조 스키마

- **key**
    - 파티션을 정할 때 사용된다. (key가 없으면 파티션이 무작위로 결정된다. (순서 보장X))
    - 키에는 비즈니스 관련 정보가 담긴다. (문자열, 숫자로 이루어짐)
    - 메시지마다 고유할 필요는 없다.
- **value**
    - payload를 의미한다. (일반 텍스트 또는 압축된 이진 블록)
- 그 외
    - **topic, partition, offset, timestamp, size, CRC**(순환 중복 검사, 주어진 데이터의 무결성 보장)

---

## 일괄 처리

- 일괄 처리가 성능 개선에 중요한 이유
    - 여러 메시지를 한 번의 네트워크 요청으로 전송하여 **값비싼 네트워크 왕복 비용을 제거**한다.
    - 로그에 기록할 때 큰 규모의 순차 쓰기 연산이 발생하여 디스크 캐시에서 큰 규모의 연속된 공간을 점유한다.
        
        → **높은 디스크 접근 대역폭을 달성**할 수 있다.
        
- 높은 대역폭과 낮은 latency는 동시에 달성하기 어려운 목표이다.
    - 낮은 latency가 더 중요하다면 일괄 처리되는 메시지 양을 낮춘다.
    - 처리량을 높이려면 토픽 당 파티션 수를 늘린다.

---

## 생산자 측 작업 흐름

### Flow 1) 생산자 → 라우팅 계층 → 브로커(리더 → 사본)

- 생산자가 메시지를 라우팅 계층으로 보낸다.
- 라우팅 계층은 메시지를 리더 사본으로 보내고, 해당 리더를 따르는 다른 사본은 리더로부터 메시지를 받는다.
- 충분한 수의 사본이 동기화되면 리더는 데이터를 디스크에 기록(commit)한다. → **데이터 소비 가능 시점**
- 기록이 끝나면 생산자에게 회신을 보낸다.

**🤔 리더와 사본이 필요한 이유?**

- 라우팅 계층을 도입하면 네트워크 노드가 하나 더 늘어나는 것이므로 네트워크 전송 지연이 늘어난다.
- 일괄 처리가 고려되지 않은 설계이다.

### Flow 2) 생산자(버퍼 → 라우팅) → 브로커(리더 → 사본)

- 라우팅 계층을 생산자로 편입시키고, 앞에 버퍼를 도입했다.

→ 네트워크를 거칠 필요가 줄어 latency가 줄어든다.

→ 메시지를 파티션에 분산시키는 로직을 생성자가 갖게 된다.

→ 메시지를 버퍼에 보관했다가 일괄 전송하여 대역폭을 높일 수 있다.

**🤔 얼마나 많은 메시지를 일괄 처리하는 것이 좋을까? (trade-off)**

- 일괄 처리양이 늘어나면 대역폭은 늘어나지만 응답 속도는 느려진다.
- 일괄 처리양이 줄어들면 대역폭은 줄어들지만 응답 속도는 빨라진다.

---

## 소비자 측 작업 흐름

- 특정 파티션의 오프셋을 주고 해당 위치에서부터 이벤트를 묶어 가져온다.

### Push(브로커 → 소비자) vs Pull(소비자 → 브로커)

- **푸시 모델**
    - 장점
        - 브로커가 메시지를 받는 즉시 소비자에게 보낼 수 있어 **낮은 latency**를 달성할 수 있다.
    - 단점
        - 생산자가 데이터 전송 속도를 좌우한다.
            - `메시지 처리 속도 < 메시지 생산 속도` 일 때 소비자에게 큰 부하가 걸릴 수 있다.
            - 소비자가 생산자의 트래픽에 맞는 컴퓨팅 자원을 항상 만족해야 한다.
- **풀 모델**
    - 장점
        - 소비자가 메시지 소비 속도를 결정할 수 있다.
            - 소비자별로 실시간으로 메시지를 가져갈 지, 일괄로 가져갈 지 구성이 가능하다.
        - `메시지 처리 속도 < 메시지 생산 속도` 일 때 유연한 대처가 가능하다.
            - 소비자를 늘려 해결한다.
            - 생산 속도를 따라잡을 때까지 기다린다.
        - 일괄 처리에 적합하다.
    - 단점
        - 브로커에 메시지가 없어도 소비자가 데이터를 끌어가려 시도해서 소비자 측 컴퓨팅 자원이 낭비된다.
            - 롱 폴링 모드 지원으로 극복한다.

→ **대부분의 메시지 큐는 푸시 모델 대신 풀 모델을 지원한다.**

---

## 소비자 재조정(Consumer Rebalancing)

- 신규 소비자 투입, 기존 소비자 제거, 특정 소비자 장애, 파티션 조정 등의 경우에 실행된다.
- **코디네이터**
    - 코디네이터는 소비자 재조정을 위해 소비자들과 통신하는 브로커 노드이다.
    - 소비자로부터 오는 heartbeat 메시지를 살피고, 각 소비자의 파티션 내 오프셋 정보를 관리한다.
    - 각 소비자는 특정 그룹에 속하고, 같은 그룹의 모든 소비자는 같은 코디네이터에 연결된다.
    - 코디네이터가 소비자들의 heartbeat 신호를 감지해서 재조정이 필요하면 재조정 프로세스를 수행한다.

---

## 상태 저장소

- 메시지 큐 브로커의 상태 저장소에 저장되는 정보
    - 소비자에 대한 파티션의 배치 관계
    - 각 소비자 그룹이 파티션에서 마지막으로 가져간 메시지 오프셋
- 소비자 상태 정보 데이터 이용 패턴
    - 읽기/쓰기가 빈번히 발생(양은 적음)
    - 데이터 갱신이 빈번히 발생, 삭제되는 일은 거의 없음
    - 읽기/쓰기 연산은 무작위적 패턴
    - 데이터 일관성이 중요함
    
    → 데이터 일관성 및 높은 읽기/쓰기 속도 요구사항을 고려했을 때 주키퍼같은 **키-값 저장소**가 바람직하다.
    

---

## 메타데이터 저장소

- 토픽 설정이나 속성 정보(파티션 수, 메시지 보관 기간, 사본 배치 정보 등)를 보관한다.
- 자주 변경되지 않으며 양도 적지만, 높은 일관성을 요구한다. → 주키퍼가 적절하다.

---

## 주키퍼

- 주키퍼란?
    - 계층적 키-값 저장소 기능을 제공하는, 분산 시스템에 필수적인 서비스이다.
    - 보통 분산 설정 서비스, 동기화 서비스, 네이밍 레지스트리 등으로 이용된다.
- 주키퍼를 이용한 구현
    - 메타데이터와 상태 저장소는 주키퍼를 이용해 구현한다.
    - 주키퍼가 브로커 클러스터의 리더 선출 과정을 돕고, 브로커는 메시지 데이터 저장소만 유지하면 된다. (역할 분리)

---

## 복제

- 분산 시스템에서 하드웨어 장애는 흔한 일이므로, 복제를 통해 대비해야한다.
- 복제 Flow
    - 생산자는 파티션에 메시지를 보낼 때 리더에게만 보내고, 다른 사본은 리더로부터 새 메시지를 지속적으로 동기화한다.
    - 메시지를 완전히 동기화 한 사본의 개수가 지정된 임계값을 넘으면 리더는 생산자에게 ack를 보낸다.
- 사본 분산 계획은 누가 어떻게 만드는가?
    - 조정 서비스의 도움으로 브로커 노드 가운데 하나가 리더로 선출되면 해당 리더 브로커 노드가 사본 분산 계획을 만든다.
    - 다른 모든 브로커는 메타데이터에 저장된 계획대로 움직인다.

---

## 사본 동기화

- **ISR(In-Sync Replicas)**
    - 리더와 동기화 된 사본을 일컫는 말이다.
    - ISR은 성능과 영속성 사이의 타협점이다.
- **ACK**
    - **ACK=all** : 생산자는 모든 ISR이 메시지를 수신한 뒤에 ACK 응답을 받는다.
        - 영속성 측면에서는 좋으나, 가장 느린 ISR의 응답을 기다려야 하므로 메시지 보내는 시간이 길어진다.
    - **ACK=1** : 생산자는 리더가 메시지를 저장하고 나면 바로 ACK 응답을 받는다.
        - 영속성을 보장하지 못하지만, 낮은 latency는 보장한다.
    - **ACK=0** : 생산자는 ACK를 기다리지 않고 계속 메시지를 전송하며, retry도 하지 않는다.
        - 지표 수집, 로깅 등 처리해야 하는 메시지의 양이 많고, 데이터 손실이 발생해도 상관 없는 경우 적합하다.

---

## 규모 확장성

### 생산자

- 새로운 생산자를 추가하거나 삭제한다.

### 소비자

- 새 소비자 그룹은 쉽게 추가하고 삭제할 수 있다.
- 같은 소비자 그룹 내 소비자가 새로 추가/삭제되는 경우 재조정 매커니즘이 맡아 처리한다.

### 브로커

- 브로커의 결함 내성을 높이기 위해 고려해야 할 점
    - 메시지가 성공적으로 committed 되었다고 판단하려면 얼마나 많은 사본에 메시지가 반영되어야 하는가?
    - 파티션의 모든 사본이 같은 브로커 노드에 있으면 장애 시 함께 소실된다.
    - 파티션의 모든 사본에 문제가 생기면 해당 파티션 데이터는 영원히 사라진다.
- 브로커 노드가 추가되거나 삭제될 때 사본을 재배치한다.
- 브로커 컨트롤러로 하여금 한시적으로 시스템에 설정된 사본 수보다 많은 사본을 허용한다.

### 파티션

- 파티션이 추가될 땐 생산자와 소비자의 안정성에 영향을 끼치지 않는다.
- 파티션이 삭제될 땐 생산자 그룹이 재조정 작업을 개시해야 한다.

---

## 메시지 전달 방식

### 최대 한 번(at-most once)

- 메시지가 전달 과정에서 소실되더라도 다시 전달되는 일은 없다. (ACK=0)
- 지표 모니터링 등 소량의 데이터 손실은 감수할 수 있는 애플리케이션에 적합하다.

### 최소 한 번(at-least once)

- 같은 메시지가 한 번 이상 전달될 수 있으나, 소실은 발생하지 않는다. (ACK=1 / ACK=all)
- 데이터 중복이 큰 문제가 아닌 애플리케이션이나 소비자가 중복을 직접 제거할 수 있는 애플리케이션의 경우 적합하다.

### 정확히 한 번(exactly once)

- 구현이 까다롭다.
- 지불, 매매, 회계 등 금융 관련 응용에는 이 전송 방식이 적합하다.

---

## 고급 기능

### 메시지 필터링

- 소비자가 일단 모든 메시지를 받은 다음 필요 없는 메시지를 버린다.
    - 불필요한 트래픽이 발생하여 시스템 성능이 저하된다.
- 브로커에서 메시지를 필터링하여 소비자는 원하는 메시지만 받을 수 있도록 한다.
    - 필터링을 위해 복호화나 역직렬화가 필요하면 브로커 성능이 저하된다.
    - 보호되어야 하는 데이터가 메시지에 포함된다면 큐에서 읽어서는 안된다.
- 필터링에 사용될 데이터를 메타데이터 영역에 두어 브로커가 효율적으로 읽어갈 수 있도록 한다.
    - 메시지마다 태그 필드를 두어 브로커가 태그를 통해 메시지를 필터링한다.

### 메시지의 지연 전송 및 예약 전송

- 메시지를 토픽에 바로 전송하지 않고, 브로커 내부의 임시 저장소에 넣어 두었다가 시간이 되면 토픽으로 옮긴다.
    - 핵심 컴포넌트: 임시 저장소, 타이밍 기능

# 4단계. 마무리

- 프로토콜 (AMQP, Kafka 등..)
    - 노드 사이에 오고 가는 데이터에 관한 규칙, 문법, API
    - 메시지 생산, 소비, heartbeat 메시지 교환
    - 대용량 데이터를 효과적으로 전송할 방법
    - 데이터의 무결성을 검증할 방법
- 메시지 소비 재시도
    - DLT 토픽에 보낸 다음 나중 다시 소비한다.
- 이력 데이터 아카이브
    - 이미 삭제된 메시지를 다시 처리하려면?
    - HDFD같은 대용량 저장소 시스템이나 객체 저장소에 보관해둔다.
- LGTM🚀

<aside>
💡 사용자에게 푸시 알림을 발행할 때 at-most once, at-least once 중 어떤 게 더 적합하다고 생각하시나요?

</aside>
