# 10장. 실시간 게임 순위표

- 순위표란?
    - 온라인 모바일 게임의 리더보드
    - 특정 토너먼트나 경연에서 누가 선두를 달리고 있는지 보여주기 위해 게임 등에서 흔히 사용하는 장치
    - 주요 경쟁자와 나의 순위가 표시됨

# 1단계. 문제 이해 및 설계 범위 확정

### 기능 요구사항

- 사용자는 경기에서 이길 때마다 1점의 포인트를 획득하고, 포인트가 점수 계산에 사용된다.
- 매달 새로운 토너먼트를 시작할 때마다 새로운 순위표를 만든다.
- 상위 10명의 사용자와 특정 사용자의 순위를 순위표에 표시한다.
    - 어떤 사용자보다 4순위 위/아래에 있는 사용자들까지 반환한다.

### 비기능 요구사항

- DAU 500만명, MAU 2,500만명
    - 각 선수는 하루 평균 10경기를 치른다.
- 순위표는 가능한 실시간에 가깝게 결과를 표시한다.

### 개략적 규모 추정

- 24시간동안 DAU가 고르게 분포한다고 가정하면, 초당 평균 50명 접속
    - 하지만 피크 시간대에 몰아서 접속하는 경향이 있으므로, 최대 부하는 평균의 5배인 250명이라고 가정
- **사용자 점수 획득 QPS**
    - 한 유저가 하루 평균 10개 게임을 플레이한다고 가정
    - QPS는 50*10=500, 최대 QPS는 500*5=2,500
- 상위 10명의 순위표 가져오기 QPS
    - 각 유저가 하루 한 번 조회한다고 가정
    - QPS는 50

# 2단계. 개략적 설계안 제시 및 동의 구하기

## API 설계

### POST /v1/score - 순위 갱신

- 사용자가 게임에서 승리하면 순위표에서 사용자의 순위를 갱신한다. (게임 서버에서만 호출할 수 있는 내부 API)
- payload - **user_id**(string), **points**(number)

### GET /v1/scores - 상위 10명의 순위표 조회

- 순위표에서 상위 10명의 플레이어를 가져온다.
- response - **data**[]: {**user_id**(string), **user_name**(string), **rank**(number), **score**(number)}, **total**(number)

### GET /v1scores/{:user_id} - 특정 사용자의 순위 조회

- 특정 사용자의 순위를 가져온다.
- payload - **user_id**(string)
- response - **user_info**: {**user_id**(string), **score**(number), **rank**(number)}

## 개략적 설계안

### ⚙️ 게임 서비스

- 사용자가 게임을 플레이할 수 있도록 한다.

### ⚙️ 순위표 서비스

- 순위표를 생성하고 표시하는 역할을 담당한다.

### 요청 흐름

- 유저가 게임에서 승리하면 클라이언트는 게임 서비스에 요청을 보낸다.
    - 게임 서비스는 유효성 체크 후 순위표 서비스에 점수 갱신 요청을 보낸다.
    - 순위표 서비스는 순위표 저장소에 기록된 해당 사용자의 점수를 갱신한다.
- 클라이언트는 순위표 서비스에 직접 요청하여 다음과 같은 데이터를 가져온다.
    - 상위 10명의 순위표
    - 해당 사용자의 순위

<aside>
🤔 **클라이언트가 순위표 서비스와 직접 통신해야 하나?**

- 클라이어트가 점수를 정하게 되면 클라이언트에서 **중간자 공격**을 할 수 있기 때문에 보안에 취약하다.
   → 점수는 서버가 설정해야 한다.
- 온라인 포커와 같이 서버가 게임 전반을 통솔하는 경우 클라리언트가 게임 서버를 명시적으로 호출할 필요가 없다.

</aside>

<aside>
🤔 **게임 서비스와 순위표 서버 사이에 메시지 큐가 필요한가?**

- 해당 데이터가 다른 곳에서도 이용되거나 여러 기능을 지원해야한다면 Kafka같은 이벤트큐를 사용하는 게 좋다.
   ex) 순위표 서비스, 분석 서비스, 푸시 알림 서비스에서 데이터를 모두 사용해야 함
- 다른 플레이어들에게 점수가 바뀌었음을 알려야하는 순번제 게임이나 멀티플레이어 게임의 경우 고려해볼만하다.

</aside>

## 데이터 모델

### RDB

- 규모 확장성이 중요하지 않고, 사용자 수가 많지 않다면 RDS를 이용할 가능성이 높다.
- 순위가 등록/변경되는 경우 간단하게 INSERT/UPDATE문으로 score 필드를 갱신한다.
- 사용자 순위 조회 시 score 기준으로 정렬한 다음 순위를 매기면 된다. (rank)

→ **이 방안은 레코드가 많아지면 성능이 나빠진다.**

- rank 함수는 비용이 비싼 함수이다. (실시간성을 요구하는 어플리케이션에 부적합)
- 데이터가 지속적으로 변경되기 때문에 캐시 도입도 불가능하다.
- score 필드에 인덱스를 추가하더라도 특정 사용자의 순위를 알기 위해서는 풀스캔이 필요하므로 성능이 떨어진다.

### Redis

- 레디스는 메모리에서 동작하므로 빠른 읽기 및 쓰기가 가능하다.
- 순위표 시스템 설계 문제를 해결하는 데 이상적인 **정렬 집합(Sorted Set)** 자료형을 제공한다.

**Sorted Set이란?**

- Set과 유사한데, Sorted Set에 저장된 각 원소는 점수에 연결되어 있다.
    - 집합 내 원소는 고유해야 하지만, 같은 점수는 있을 수도 있다.
    - 점수는 Sorted Set 내 원소를 오름차순 정렬하는 데 이용된다.
- 내부적으로 **해시테이블**과 **스킵 리스트** 두 가지 자료 구조를 사용한다.
    - **해시테이블**: 사용자의 점수를 저장하기 위해 사용
    - **스킵 리스트**: 특정 점수를 딴 사용자들의 목록을 저장하기 위해 사용
    
    <aside>
    💡 **스킵 리스트**
    
    정렬된 연결 리스트에 다단계 색인을 두는 구조로, 빠른 검색을 가능하게 하는 자료구조
     - 연결리스트에 삽입/삭제/검색 연산을 하는 시간복잡도는 `O(n)`
     - 연산을 빠르게 하기 위해 이진 검색처럼 중간 노드를 건너뛰는 1차 색인, 2차 색인을 추가한다.
     - 노드 사이의 거리가 n-1이 될 때까지 색인을 추가한다.
     - 그렇게 하면 삽입/삭제/검색 연산의 시간 복잡도가 `O(log(n))`이 된다.
    
    </aside>
    

**Redis Sorted Set을 사용한 구현**

- `ZADD`
    - 기존에 없던 사용자를 집합에 삽입한다. (UPSERT)
    - **O(log(n))**
- `ZINCRBY`
    - 사용자의 점수를 지정된 값만큼 증가시킨다. (UPSERT)
    - **O(log(n))**
- `ZRANGE`/`ZREVRANGE`
    - 점수에 따라 정렬된 사용자 중 특정 범위에 드는 사용자들을 가져온다.
    - 순서, 항목 수, 시작 위치를 지정할 수 있다.
    - **O(log(n) + m)** - m:가져올 항목 수 / n: 정렬 집합의 크기
- `ZRANK`/`ZREVRANK`
    - 오름차순/내림차순 정렬하였을 때 특정 사용자의 위치를 가져온다.
    - **O(log(n))**

**Sorted Set을 사용한 구현의 동작 원리**

- **사용자가 점수를 획득한 경우**
    - 매월 새로운 순위표를 위한 Sorted Set을 만들고, 이전 순위표는 이력 데이터 저장소로 보낸다.
    - 사용자가 경연에서 승리하면 1점을 얻는다. 
    → `ZINCRBY leaderboard_apr_2024 1 ‘hyemsterr’`
- **사용자가 순위표 상위 10명을 조회하는 경우**
    - 가장 높은 점수를 받은 사용자부터 내림차순으로 조회한다. 
    → `ZREVRANGE leaderboard_apr_2024 0 9 WITHSCORES`
    - 그러면 아래와같은 목록이 반환된다.
    → [(hyemsterr, 100), (cheese, 80), (behappyalltt, 60)]
- **사용자가 자기 순위를 조회하는 경우**
    - 특정 사용자의 순위를 가져온다.
    → `ZREVRANK leaderboard_apr_2024 ‘hyemsterr’`
- **특정 사용자 순위를 기준으로 일정 범위 내 사용자를 질의하는 경우**
    - 내 순위가 361이고, 전 후 사용자 4명씩을 조회한다.
    → `ZREVRANGE leaderboard_apr_2024 357 365`

### 저장소 요구사항

- 최대로 필요한 저장공간
    - MAU 2,500만명 모두가 최소 한 번 이상 게임에서 승리하여 모두 월 순위표에 오른다.
        - ID가 CHAR(24), 점수가 16bit라고 가정 → 한 항목 당 26byte 필요
            
            → 26byte * 2,500만 = **650MB**의 저장공간이 레디스 캐시에 필요
            
            - 최신 레디스 한 대만으로도 충분히 감당 가능하다.
- 데이터의 영속성 문제
    - 레디스는 데이터를 디스크에 영속적으로 보관하는 옵션도 제공한다.
    - 디스크에서 데이터를 읽어 대규모 레디스 인스턴스를 재시작하려면 시간이 많이 걸린다.
    - 보통은 레디스에 읽기 사본을 두는 식으로 구성한다.
        - 장애가 생기면 읽기 노드를 주 서버로 승격시키고, 새로운 읽기 사본을 만들어 연결한다.
- 최적화 방안
    - 가장 자주 검색되는 상위 10명의 사용자 정보를 캐시한다.

# 3단계. 상세 설계

## 클라우드 서비스 사용 여부

- 솔루션 배포 방식을 인프라 구성 형태에 따라 두 가지로 나누어서 알아보자.

### 자체 서비스를 이용하는 방안

- **Redis**: 순위표 정렬 집합(Zset), 상위 10명 사용자 프로필 캐시
- **MySQL**: 사용자 프로필 및 사용자 점수 정보 저장

### 클라우드 서비스를 활용하는 방안

- **API Gateway**를 사용해서 RESTful API 엔드포인트를 정의한다.
- **AWS Lambda**를 통해 API 엔드포인트와, 실제 엔드포인트로 접근 시 동작할 함수를 연결한다.

<aside>
💡 **AWS Lambda**

- 가장 인기 있는 서버리스 컴퓨팅 플랫폼
- 필요할 때만 실행되며, 트래픽에 따라 규모가 자동으로 확장된다.
   → 규모 확장, 환경 설정, 유지 보수 등의 문제를 직접 관리할 필요가 없다.

</aside>

## 레디스 규모 확장

- 500만 DAU라면 레디스 캐시 서버 한 대로 충분히 지원 가능하다.
- 최대 예상 규모인 5억 DAU라면..? 65GB의 저장 용량과 25만 QPS의 질의를 감당해야 한다😱 → **샤딩**이 꼭 필요하다.

### 고정 파티션

- 순위표에 등장하는 점수의 범위에 따라 파티션을 나누는 방안
    - ex) [1~100], [101~200], [201~300] …
- 이 기능이 제대로 작동하려면 순위표 전반에 점수가 고르게 분포되어야 한다.
    - 그렇지 않다면 각 샤드에 할당되는 점수 범위를 조정하여 비교적 고른 분포가 되도록 해야 한다.
- **🤔 특정 사용자의 점수를 입력하거나 갱신할 때 해당 사용자가 어느 샤드에 있는지 어떻게 알아낼까?**
    - MySQL 질의를 통해 사용자의 현재 점수를 계산하여 알아낸다.
    - 사용자 ID와 점수 사이의 관계를 저장하는 2차 캐시를 통해 알아낸다.
- **🤔 특정 사용자의 순위를 알아내려면?**
    - 해당 사용자가 속한 샤드 내 순위 뿐 아니라 해당 샤드보다 높은 점수의 모드 샤드의 모든 사용자 수를 알아야 한다.
        - 특정 샤드에 속한 모든 사용자 수는 `info keyspace` 명령을 통해 O(1) 시간에 알아낼 수 있다.
- **🤔 순위표에서 상위 10명의 플레이어를 가져오려면?**
    - 가장 높은 점수가 저장되는 샤드에서 상위 10명을 가져온다.

### 해시 파티션

- **레디스 클러스터**를 사용하는 방법으로, 사용자들의 점수가 특정 대역에 과도하게 모여 있는 경우 효과적이다.
- 레디스 클러스터는 안정 해시 대신 각각의 키가 특정한 **해시 슬롯**에 속하도록 하는 샤딩 기법을 사용한다.
    - 총 16,384개의 해시 슬롯이 있고, `CRC16(key)%16384` 연산을 수행하여 어떤 키가 어느 슬롯에 속하는지 계산한다.
    - 따라서 모든 키를 재분배하지 않아도 클러스터에 쉽게 노드를 추가하거나 제거할 수 있다.
- **🤔 특정 사용자의 점수를 입력하거나 갱신할 때 해당 사용자가 어느 샤드에 있는지 어떻게 알아낼까?**
    - `CRC16(key)%16384` 연산으로 특정 사용자의 샤드를 찾는다.
- **🤔 특정 사용자의 순위를 알아내려면?**
    - `CRC16(key)%16384` 연산으로 찾은 샤드에서 해당 사용자 점수를 변경한다.
- **🤔 순위표에서 상위 10명의 플레이어를 가져오려면?**
    - 모든 샤드에서 상위 10명을 받아 애플리케이션 내에서 다시 정렬한다. (분산-수집 접근법)
    - 모든 샤드에 사용자를 질의하는 절차를 병렬화하면 지연 시간을 줄일 수 있다.
- 이 방식에는 다음과 같은 문제가 있다.
    - 상위 k개의 결과를 반환해야 하는 경우, 각 샤드에서 많은 데이터를 읽고 정렬해야 하므로 지연 시간이 늘어난다
    - 가장 느린 파티션에서 데이터를 다 읽고 나서야 질의 결과를 계산할 수 있으므로 지연 시간이 길어진다.
    - 특정 사용자의 순위를 결정할 간단한 방법이 없다.

→ 본 설계안에서는 **고정 파티션** 방안을 사용한다.

### 레디스 노드 크기 조정

- 쓰기 작업이 많은 애플리케이션에는 많은 메모리가 필요하다.
    - 장애에 대비해 스냅숏을 생헝할 때 필요한 모든 쓰기 연산을 감당할 수 있어야 한다.
    - 쓰기 연산이 많은 애플리케이션에는 메모리를 두 배 더 할당하는 것이 안전하다.
- 레디스는 성능 벤치마킹을 위해 **redis-benchmark**라는 도구를 제공한다.
    - 여러 클라이언트가 동시에 여러 질의 실행하는 것을 시뮬레이션하여 처리 가능한 TPS를 측정한다.

## Redis와 MySQL의 대안: NoSQL

- 어떤 DB가 이상적일까?
    - 쓰기 연산에 최적화되어 있다.
    - 같은 파티션 내 항목을 점수에 따라 효율적으로 정렬 가능하다.
- **AWS DynamoDB**
    - 안정적인 성능과 뛰어난 확장성을 제공하는 완전 관리형 NoSQL 데이터베이스
    - 기본키 외에 **전역 보조 색인(global secondary index)**을 제공하여 데이터를 효과적으로 질의할 수 있게 한다.
        - `game_name#{year-month}`를 파티션 키로 지정하고, `score`를 정렬 키로 지정한다.
            
            → 풀스캔을 피하고, 특정 파티션 내에서만 조회하여 정렬된 결과를 얻을 수 있다.
            
            → **DynamoDB는 안정 해시를 사용하는데, 핫 파티션이 되어 부하가 높을 땐 문제가 된다.**
            
    - 위의 문제를 해결하기 위해 **쓰기 샤딩 패턴**을 사용한다.
        - 데이터를 n개 파티션으로 분할하고, 파티션 번호를 파티션 키에 추가한다. 
        → `game_name#{year-month}#{partition_number}`
        - 상위 10명의 사용자를 가져오려면 분산-수집 접근법을 사용한다.
        - 추가로 각 샤드의 점수 분포를 부석한 결과를 캐시하는 cron job을 따로 두어 빠르게 계산할 수 있도록 한다.

# 4단계. 마무리

### 더 빠른 조회 및 동점자 순위 판정 방안

- **Redis Hash**를 사용하면 문자열 필드와 값 사이의 대응 관계를 저장해 둘 수 있다.
    - 사용자 ID와 사용자 객체 사이의 대응 관계를 저장하여 DB 질의 횟수를 줄인다.
    - 두 유저의 점수가 같은 경우 timestamp에 따라 순위를 결정한다.

### 시스템 장애 복구

- 유저가 게임에서 이길 때마다 MySQL DB에 timestamp와 함께 기록된다는 사실을 활용하는 스크립트를 만들어 복구한다.
    - 유저별로 모든 레코드를 훑으면서 레코드당 한 번씩 `ZINCRBY`를 호출한다.
    - 대규모 장애 발생 시 오프라인 상태에서 순위표를 복구할 수 있다.
