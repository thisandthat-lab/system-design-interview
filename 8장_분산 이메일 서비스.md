# 8장. 분산 이메일 서비스

# 1단계. 문제 이해 및 설계 범위 확정

### 기능 요구사항

- 이메일 발송/수신 및 모든 이메일 가져오기
- 첨부파일 지원
- 읽음 여부에 따른 필터링 및 제목, 발신인, 메일 내용 등 검색
- 스팸 및 바이러스 방지
- **HTTP 프로토콜 사용** (전통적으로는 SMTP, POP, IMAP 등의 프로토콜 사용)

### 비기능 요구사항

- **안정성**: 이메일 데이터는 소실되면 안된다.
- **가용성**: 부분적으로 장애가 발생해도 시스템은 동작해야하며, 이를 위해 이메일과 사용자 데이터를 여러 노드에 복제해둔다.
- **확장성**: 사용자나 이메일이 많아져도 성능이 저하되지 않아야 한다.
- **유연성**: 새 컴포넌트를 더하여 쉽게 기능을 추가하고 성능을 개선할 수 있어야 한다. (POP, IMAP은 제한적)

### 개략적 규모 추정

- 10억 명의 사용자, 한 사람이 하루에 보내는 평균 이메일 수는 10건이라고 가정
    
    → **QPS** = 10^9 * 10 / 10^5 = **100,000**
    
- 한 사람이 하루에 수신하는 이메일 수는 평균 40건이라고 가정, 이메일 하나의 메타데이터는 평균 50MB라고 가정
    
    → **1년동안의 스토리지 요구사항** = 10억명 * 하루 40건의 이메일 * 365일 * 50KB = **730PB**
    
- 첨부파일이 포함된 이메일의 비율은 20%, 첨부파일의 평균 크기는 500KB라고 가정
    
    → **1년동안의 첨부파일 저장 용량** = 10억명 * 하루 40건의 이메일 * 365일 * 20% * 500KB = **1,460PB**
    

→ 많은 데이터를 처리해야 하므로 **분산 데이터베이스 솔루션**이 필요하다.

# 2단계. 개략적 설계안 제시 및 동의 구하기

## 이메일 101

### 이메일 프로토콜

- **SMTP (Simple Mil Transfer Protocol)**
    - 이메일을 한 서버에서 다른 서버로 보내는 표준 프로토콜
- **POP (Post Office Protocol)**
    - 클라이언트가 원격 메일 서버에서 이메일을 수신하고 다운로드하기 위해 사용하는 표준 프로토콜
    - 단말로 다운로드된 이메일은 서버에서 삭제된다. → 한 대 단말에서만 이메일을 읽을 수 있다.
    - 이메일을 확인하려면 전부 내려받아야 한다. (일부만 읽을 수 없음)
- **IMAP (Internet Mail Access Protocol)**
    - 클라이언트가 원격 메일 서버에서 이메일을 수신하고 다운로드하기 위해 사용하는 표준 프로토콜
    - POP과 달리 다운로드 후에도 메일 서버에서 삭제되지 않는다. → 여러 대 단말에서 읽을 수 있다.
    - 메일을 열기 전에는 헤더만 다운로드하기 때문에 인터넷 속도가 느려도 잘 동작한다.
- **HTTPS**
    - 메일 전용 프로토콜은 아니지만, 웹 기반 이메일 시스템의 메일함 접속에 이용될 수 있다.
    - ex) MS Outlook은 ActiveSync라는 HTTPS 기반 자체 프로토콜을 사용함

### 도메인 이름 서비스 (DNS)

- 수신자 도메인의 MX레코드(메일 교환기 레코드) 검색에 이용된다.
- 검색된 MX레코드들 중 우선순위에 따라 연결을 시도한다.

### 첨부 파일

- 일반적으로 Base64 인코딩을 사용한다.
- 일반적으로 크기 제한을 둔다.
- **MIME(Multi-purpose Internet Mail Extension)**은 인터넷을 통해 첨부 파일을 전송하는 표준 규격이다.

## 전통적 메일 서버

### 전통적 메일 서버 아키텍처

- 채은이가 아웃룩 클라이언트에 로그인하여 메일 ‘보내기’ 버튼을 누르면 메일은 아웃룩 메일 서버로 전송된다. (SMTP)
- 아웃룩 메일 서버는 DNS 질의를 통해 수신자 SMTP 서버 주소를 찾고, 해당 서버로 메일을 전송한다. (SMTP)
- 해당 서버(지메일)는 이메일을 저장한다.
- 지현이가 지메일에 접속하면 지메일 클라이언트는 IMAP/POP 서버를 통해 새 이메일을 가져온다.

### 저장소

- 메일을 파일 시스템의 디렉토리에 저장한다. (`home > hrwoo > **Maildir** > cur / new / tmp`)
    - 메일의 양이 많아지고 파일 구조가 복잡해지면 디스크 I/O가 병목이 된다.
    - 디스크 손상이나 서버 장애 가능성으로 인해 가용성과 안정성 요구사항도 만족할 수 없다.
    
    → POP, IMAP, SMTP의 한계.. 안정적인 분산 데이터 저장소 계층이 필요하다!
    

## 분산 메일 서버

- 현대적 사용 패턴을 지원하고, 확장성과 안정성 문제를 해결한다.

### 이메일 API

- **`POST` /v1/message**
    - To, Tc, Bcc 헤더에 명시된 수신자에게 메시지를 전송한다.
- **`GET` /v1/folders**
    - 주어진 이메일 계정에 존재하는 모든 폴더를 반환한다.
- **`GET` /v1/folders/{:folder_id}/message**
    - 주어진 폴더 아래의 모든 메시지를 반환한다.
- **`GET` /v1/messages/{:message_id}**
    - 주어진 특정 메시지에 대한 모든 정보(발신자, 수신자, 제목, 본문, 첨부 파일 등)를 반환한다.

### 분산 메일 서버 아키텍처

- **웹메일**
    - 사용자는 웹브라우저를 사용해 메일을 주고받는다.
- **웹서버 (웹메일 → 웹서버, HTTPS)**
    - 이메일 발송, 폴더 목록 확인, 폴더 내 모든 메시지 확인 등의 모든 이메일 API 요청을 처리한다.
- **실시간서버 (웹메일 → 실시간서버, 웹소켓)**
    - 새로운 이메일 내역을 클라이언트에 실시간으로 전달한다.
    - 기본적으로 웹소켓을 쓰되, 여의치 않으면 롱 폴링을 백업으로 이용한다.
- **메타데이터 DB**
    - 이메일 제목, 본문, 발신인, 수신인 목록 등의 메타데이터를 저장하는 데이터베이스이다.
- **첨부파일 저장소**
    - **AWS S3**같은 객체 저장소를 사용한다.
    - 💡 카산드라같은 NoSQL DB가 부적합한 이유
        - BLOB가 지원하는 최대 크기가 2GB이긴 하나, 실질적으로는 1MB 이상의 파일을 지원하지 못함
        - 첨부파일이 메모리를 많이 소모하여 레코드 캐시를 사용하기 어려움
- **분산 캐시**
    - **Redis**를 활용한다.
    - 최근에 수신된 이메일을 메모리에 캐시해둔다.
- **검색 저장소**
    - 고속 텍스트 검색을 지원하는 역인덱스를 자료구조로 사용한다.

### 이메일 전송 절차

- 사용자가 웹메일 작성 후 전송 버튼을 누르면 요청은 LB로 전송되고, LB에서 요청을 웹서버로 전다한다.
    - 이메일 검증
    - `수신자 이메일 주소 도메인 == 송신자 이메일 주소 도메인`인지 검사
        - 내부 메일인 경우 스팸 여부와 바이러스 감염 여부만 검사 후 내부적으로 메일 저장
        - 외부 메일인 경우 외부 전송 큐로 전달
- **외부 전송 담당 SMTP 작업 프로세스**
    - 외부 전송 큐에서 메시지를 꺼내 스팸 여부와 바이러스 감염 여부를 검사한다.
    - 수신자의 메일 서버로 메일을 전송한다.

→ 웹 서버에서 외부 전송 담당 SMTP 프로세스를 분리함으로써 독립적 규모 확장이 가능해졌다.

### 이메일 수신 절차

- 메일이 SMTP LB에 전송되면 트래픽을 여러 SMTP 서버로 분산한다.
    - SMTP 연결에 유효하지 않은 이메일 반송 정책 등을 구성하여 적용할 수 있다.
- 첨부파일이 큐에 들어가기 너무 큰 경우 S3에 보관한다.
- 이메일을 수신 이메일 큐에 넣는다.
    - 메일 처리 작업 프로세스와 SMTP 서버 간 결합도를 낮추어 독립적 규모 확장이 가능하다.
    - 갑자기 수신되는 이메일의 양이 폭증하는 경우 버퍼 역할도 한다.
- 메일 처리 작업 프로세스가 스팸 메일을 거르고 바이러스 차단 등의 기능을 수행한다.
- 이메일을 메일 저장소, 캐시, 객체 저장소 등에 보관한다.
- 수신자가 온라인 상태인 경우 이메일을 실시간 서버로 전달한다.
- 수신자가 오프라인 상태인 경우 이메일은 저장소 계층에 보관한다.

# 3단계. 상세 설계

## 메타데이터 데이터베이스

### 이메일 메타데이터의 특성

- 헤더는 일반적으로 작고, 빈번하게 이용된다.
- 본문의 크기는 천차만별이지만, 사용 빈도는 낮다. (일반적으로 사용자는 메일을 한 번만 읽는다.)
- 메일 가져오기, 읽음 표시, 검색 등의 작업은 사용자별로 격리 수행되어야 한다.
- 데이터의 신선도는 데이터 사용 패턴에 영향을 미친다.
    - 일반적으로 사용자는 보통 최근 메일만 읽는다.
    - 16일이 지나지 않은 데이터를 읽는 비율은 전체 질의의 82%에 달한다.
- 데이터는 높은 안정성이 보장되어야 한다. (손실은 절대 용납되지 않는다.)

### 올바른 데이터베이스의 선정

- **RDB**
    - 검색의 효율성
        - 메일 헤더와 본문에 대한 인덱스로 간단한 검색 질의를 빠르게 처리할 수 있다.
    - 데이터 크기가 작을 때 적합함
        - BLOB 자료형에 대한 검색 질의 성능은 좋지 않다. (많은 디스크 I/O 발생)
        
        → MySQL이나 PostgreSQL같은 RDB는 부적합하다.
        
- **분산 객체 저장소**
    - 이메일의 원시 데이터를 그대로 S3같은 객체 저장소에 보관한다.
    - 백업 데이터를 보관하기에는 좋지만 읽음 표시, 키워드 검색, 스레드 등의 기능을 구현하기에는 부적합하다.
- **NoSQL DB**
    - 지메일은 구글 빅테이블을 사용한다.
        - 하지만 오픈소스가 아니고, 어떻게 구현했는지 알 방법이 없다.
    - 대형 이메일 서비스 제공 업체 중 카산드라를 사용하는 곳은 확인된 바가 없다.

→ 완벽히 들어맞는 디비는 없고, 보통 대형 이메일 서비스 업체는 독자적인 디비 시스템을 만들어 사용한다.

- 어떤 단일 컬럼의 크기는 한 자릿수 MB 정도일 수 있다.
- 강력한 데이터 일관성이 보장되어야 한다.
- 디스크 I/O가 최소화되도록 설계되어야 한다.
- 가용성이 높아야하고, 일부 장애를 감내할 수 있어야 한다.
- 증분 백업이 쉬워야 한다.

### 데이터 모델

- user_id를 파티션 키로 사용하여 특정 사용자의 데이터는 항상 같은 샤드에 보관한다.
    - 메시지를 여러 사용자와 공유할 수 없다는 문제가 있다.
- 기본 키는 파티션키와 클러스터키 두 가지 부분으로 구성된다.
    - **파티션키**: 데이터를 여러 노드에 분산하는 역할을 한다.
    - **클러스터키**: 같은 파티션에 속한 데이터를 정렬하는 역할을 한다.
- 다음과 같은 질의를 지원해야한다.
    - **특정 사용자의 모든 폴더 질의**
        - 파티션키로 사용자를 질의하고, 클러스터키로 정렬한다.
    - **특정 폴더에 속한 모든 이메일 표시**
        - 같은 폴더에 속한 모든 이메일이 같은 파티션에 속하도록 하려면 <user_id, folder_id> 형태의 복합 파티션 키를 사용해야 한다.
    - **이메일 생성/삭제/수신**
    - **읽은/읽지 않은 모든 메일 질의**
        - NoSQL 데이터베이스는 파티션 키와 클러스터 키에 대한 질의만 허용한다. (is_read = true 처럼 질의 불가)
        - 모든 메시지 조회 후 어플리케이션단에서 필터링한다. → 대규모 서비스에는 부적합하다.
        
        → NoSQL 테이블을 비정규화하여 해결한다. (read_emails, unread_emails)
        
    - **이메일 타래(threads) 가져오기**
        - JWZ같은 알고리즘을 통해 구현한다.
        - 메일헤더의 Message-Id, In-Reply-To, References 필드들을 이용해서 전체 대화 타래를 구성한다.
