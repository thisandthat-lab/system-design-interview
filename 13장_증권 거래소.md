> *거래소의 기본 기능: 구매자와 판매자가 효율적으로 연결될 수 있도록 돕는 것*
> 

# 1단계. 문제 이해 및 설계 범위 확정

### 기능 요구사항

- 새 주문, 주문 취소 기능을 제공하고, 지정가 주문 유형만 지원한다.
- 시간 내 거래만 처리한다.
- 호가 창(매수 및 매도 주문 목록이 표시되는 곳)의 정보는 실시간으로 갱신되어야 한다.
- 거래소는 규제 시설이므로 위험성 점검이 가능해야 한다.
- 주문 전 충분한 자금이 있는지 먼저 확인한다.

### 비기능 요구사항

- High Availability: 최소 99.99%의 가용성이 필요하다.
- Low Latency: 왕복 지연 시간은 밀리초 수준이어야 한다.
- 결함 내성
- 보안

### 개략적 규모 추정

- 100가지 종류의 주식과 하루 10억 건의 주문이 발생한다.
- 월~금 09:30~16:00까지 총 6.5시간 영업한다.

→ 10억/6.5시간*3600 = 약 `43,000 QPS`

→ 최대 QPS는 5*43,000 = 약 `215,000 QPS` (장 시작 직후, 장 마감 직전에 거래량이 높아진다.)

# 2단계. 개략적 설계안 제시 및 동의 구하기

## 증권 거래 101

### 브로커

- 개인 사용자가 증권을 거래하고 시장 데이터를 확인할 수 있도록 편리한 사용자 인터페이스를 제공한다.
- 찰스 슈왑, 로빈후드, E*트레이드, 피델리티 등

### 기관 고객

- 전문 증권 거래 소프트웨어를 사용하여 대량으로 거래하는 고객이다.
- 거래 빈도는 낮지만 거래량은 많아 대규모 주문이 시장에 미치는 영향을 최소화하기 위해 주문 분할 같은 기능이 필요하다.
- 아주 낮은 응답 시간으로 거래하기를 원하며, 일반 사용자와 동일하게 웹이나 앱에서 시장 데이터를 확인하게 하면 곤란하다.

### 지정가 주문

- 가격이 고정된 매수 또는 매도 주문이다.
- 시장가 주문과는 달리 체결이 즉시 이루어지지 않을 수 있고, 부분적으로만 체결될 수도 있다.

### 시장가 주문

- 가격을 지정하지 않는 주문으로, 시장가로 즉시 체결된다.
- 체결은 보장되나 비용 면에서는 손해를 볼 수 있으며, 급변하는 특정 시장 상황에서 유용하다.

### 시장 데이터 수준

- L1: 최고 매수 호가, 매도 호가, 수량이 포함된다.
- L2: 매도 주문 깊이, 최저 매도 주문 등 더 많은 수준의 가격 정보가 제공된다.
- L3: 각 주문 가격에 체결을 기다리는 물량 정보까지 제공된다.

### 봉 차트

- 특정 기간 동안의 주가로, 하나의 봉 막대로 일정 시간 간격 동안 시장의 시작가, 종가, 최고가, 최저가를 표시한다.

### FIX

- Financial Information Exchange Protocol, 즉 금융 정보 교환 프로토콜의 약어이다.
- 증권 거래 정보 교환을 위한 기업 중립적 통신 프로토콜이다.

## 개략적 설계안

![Uploading image.png…]()

- **💸 거래 흐름**
    - 고객이 브로커의 웹 또는 앱을 통해 주문하면, 브로커는 클라이언트 게이트웨이를 통해 주문을 거래소에 전송한다.
    - 주문 관리자에서 위험 관리자가 설정한 규칙에 따라 위험성 점검을 수행하고, 지갑의 자금이 충분한지 확인한다.
    - 주문이 체결 엔진으로 전송되고, 체결 가능 주문이 발견되면 매수 측과 매도 측에 각각 하나씩 집행 기록을 생성한다.
        - 이 때 시퀀서가 주문 및 집행 기록을 일정 순서로 정렬한다.
    - 마지막으로 주문 집행 사실을 클라이언트에 전송한다
    
    <aside>
    💡 **체결 엔진**
    
    - 각 주식 심벌에 대한 주문서 내지 호가 창을 유지 관리한다.
    - 매수 주문과 매도 주문을 연결한다. (주문 체결 결과로 두 개의 집행 기록이 만들어진다.)
    - 집행 기록 스트림을 시장 데이터로 배포한다.
    </aside>
    
    <aside>
    💡 **시퀀서**
    
    - 체결 엔진을 결정론적으로 만드는 핵심 구성 요소이다.
        - 입력으로 주어지는 주문 순서가 같으면, 체결 엔진이 만드는 집행 기록 순서는 언제나 동일해야 한다.
    - 입력 시퀀서와 출력 시퀀서 두 가지가 있어 각각 고유한 순서를 유지한다.
    - 시퀀서가 만드는 시퀀스는 누락된 항목을 쉽게 발견할 수 있는 일련번호여야 한다.
    - 입력되는 주문과 출력하는 실행 명령에 순서 ID를 찍는 이유
        - 시의성 및 공정성 / 빠른 복구 및 재생 / 정확한 1회 실행 보증
    - 시퀀서가 MQ 역할 또한 담당하고, 주문과 집행 기록을 위한 이벤트 저장소로도 볼 수 있다.
    </aside>
    
    <aside>
    💡 **주문 관리자**
    
    - 클라이언트 게이트웨이를 통해 **주문을 수신**하고 다음을 실행한다.
        - 종합적 위험 담당 컴포넌트에 주문을 보내 위험성을 검토한다.
        - 사용자의 지갑에 거래를 처리하기에 충분한 자금이 있는지 확인한다.
        - 주문을 시퀀서에 전달한다. (메시지 크기를 줄이기 위해 필요한 속성만 전송한다.)
    - 시퀀서를 통해 체결 엔진으로부터 **집행 기록을 수신**한다.
        - 체결된 주문에 대해 집행 기록을 브로커에 반환한다.
    - 이벤트 소싱은 주문 관리자 설계에 적합하다.
    </aside>
    
    <aside>
    💡 **클라이언트 게이트웨이**
    
    - 지연 시간에 민감하고 가벼워야 한다. (ASAP)
    - 복잡한 기능은 체결 엔진이나 위험 점검 컴포넌트에 맡겨야 한다.
    </aside>
    
- **💿 시장 데이터 흐름**
    - 체결 엔진이 생성한 집행 기록 스트림이 시장 데이터 게시 서비스로 전송된다.
    - 시장 데이터 게시 서비스는 집행 기록과 주문 스트림에서 얻은 데이터를 가지고 **봉 차트**와 **호가 창**을 구성한다.
    - 이후 데이터는 실시간 분석 전용 스토리지에 저장된다.
    - 브로커는 데이터 서비스를 통해 실시간 시장 데이터를 읽어와 고객에게 전달한다.
- **🖊 보고 흐름**
    - 보고 서비스는 주문 및 실행 기록에서 보고에 필요한 모든 필드의 값을 병합하여 DB에 기록한다.
    - 거래 이력, 세금 보고, 규정 준수 여부 보고, 결산 등의 기능을 제공한다.
    - 효율성과 짧은 지연 시간보다는 정확성과 규정 준수가 더 중요하다.

## API 설계

- **주문** - `POST` /v1/order
    - 주문을 처리하는 API로, 인증이 필요하다.
    - payload: **symbol**, **side**[buy|sell], **price,** **orderType**[limit|market], **quentity**
    - response: **id**, **creationTime**, **filledQuentity,** **remainingQuantity,** **status**[new|canceled|filled]
- **집행** - `GET` /v1/exclution
    - 집행 정보를 질의하는 API로, 인증이 필요하다.
    - payload: **symbol**, **orderId**, **startTime**, **endTime**
    - response: **executions**, **id**, **orderId**, **symbol**, **side**[buy|sell], **price**, **orderType**[limit|market], **quentity**
- **호가 창/주문서** - `GET` /v1/marketdata/orderBook/L2
    - 주어진 주식 심벌, 주어진 깊이 값에 대한 L2 호가 창 질의 결과를 반환한다.
    - payload: **symbol**, **depth**, **startTime**, **endTime**
    - response: **bids**, **asks**
- **가격 변동 이력(봉 차트)** - `GET` /v1/marketdata/candles
    - 주어진 시간 범위, 해상도, 심벌에 대한 봉 차트 데이터 질의 결과를 반환한다.
    - payload: **symbol**, **resolution**, **startTime**, **endTime**
    - response: **candles**, **open**, **close**, **high**, **low**

## 데이터 모델

### 상품, 주문, 집행

- 상품
    - 상품 유형, 심벌, 통화 단위, 매매 수량 단위, 호가 가격 단위 등 거래 대상 주식(즉 심벌)이 가진 속성으로 정의된다.
    - 이 데이터는 자주 변경되지 않으므로 아무 데이터베이스에나 저장 가능하며, 캐시를 적용하기도 좋다.
- 주문과 집행 기록
    - 주문은 매수 또는 매도를 실행하라는 명령이고, 집행 기록은 체결이 이루어진 결과로, 모든 주문이 집행되지는 않는다.
    - 체결 엔진은 하나의 주문 체결에 관여한 매수 행위와 매도 행위를 나타내는 두 개의 집행 기록을 결과로 출력한다.
    - 주문과 집행 기록은 1:0..N, 주문과 상품은 1:1 관계를 가진다.
    - 중요 거래 경로는 메모리에서 거래를 체결하고, 하드디스크나 공유 메모리를 활용하여 주문과 집행 기록을 저장한다.
    - 빠른 복구를 위해 시퀀서에 저장하고, 데이터 보관은 장 마감 후에 실행한다.
    - 보고 서비스는 조정이나 세금 보고 등을 위해 데이터베이스에 주문 및 집행 기록을 저장한다.
    - 집행 기록은 시장 데이터 프로세서로 전달되어 호가 창/주문서와 봉 차트 데이터 재구성에 쓰인다.

### 호가 창

- 특정 증권 또는 금융 상품에 대한 매수/매도 주문 목록으로, 가격 수준별로 정리되어 있다.
- 호가 창의 자료 구조는 다음 요구사항을 만족해야 한다.
    - 특정 가격 수준의 주문량 조회, 특정 가격 범위 내의 주문량 조회 시에도 일정한 조회 시간이 소요되어야 한다.
    - 가급적 O(1) 시간 복잡도를 만족해야 한다. (새 주문 넣기, 주문 취소, 주문 체결 등)
    - 최고 매수 호가, 최저 매도 호가 질의와 가격 수준 순회를 제공해야 한다.
    - **이중 연결 리스트** 자료 구조를 활용해야 한다.
        - 새 주문을 넣는 것 → 리스트 마지막에 새 Order를 추가하는 것 → O(1)
        - 주문을 체결한다는 것 → 리스트 맨 앞의 Order를 삭제하는 것 → O(1)
        - 주문을 취소한다는 것 → Map 자료구조에서 주문을 찾아 취소하는 것 → O(1)

### 봉 차트

- 시장 데이터 프로세서가 시장 데이터를 만들 때 호가 창과 더불어 사용하는 핵심 자료 구조이다.
- 봉 차트 모델링을 위해 Candlestick, CandlestickChart 클래스를 사용한다.
    - 하나의 봉이 커버하는 시간 범위가 경과하면 다음 주기를 커버할 새 Candlestick 클래스 객체를 생성하고,
    CandlestickChart 객체 내부 연결 리스트에 추가한다.
- 메모리 최적화 방법
    - 미리 메모리를 할당해 둔 링 버퍼에 봉을 보관하여 새 객체 할당 횟수를 줄인다.
    - 메모리에 두는 봉의 개수를 제한하고 나머지는 디스크에 보관한다.
- 시장 데이터는 일반적으로 실시간 분석을 위해 메모리 상주 칼럼형 데이터베이스에 둔다.

# 3단계. 상세 설계

## 성능

- 평균 지연 시간은 낮아야하고, 전반적인 지연 시간 분포는 안정적이어야 한다. (p99)
    - 중요 경로에서 실행할 작업 수를 줄인다.
    - 각 작업의 소요 시간을 줄인다. (네트워크 및 디스크 사용량 경감 / 각 작업의 실행 시간 경감)

→ 모든 구성요소를 단일 서버에 배치하여 낮은 지연 시간을 달성한다.

→ **애플리케이션 루프**를 도입한다.

- 애플리케이션 루프에서 while 순환문을 통해 실행할 작업을 계속해서 폴링한다.
    - 목적 달성에 가장 중요한 작업만 이 순환문 안에서 처리한다.
- CPU 효율성을 극대화하기 위해 단일 스레드로 구현하며, 특정 CPU 코어에 고정시킨다.
    - 컨텍스트 스위칭이 없다.
    - 단일 스레드에서 동작하므로 락을 사용할 필요가 없다.

## 이벤트 소싱

- 이벤트 소싱 아키텍처는 현재 상태를 저장하는 대신 상태를 변경하는 모든 이벤트의 immutable 로그를 유지한다.
    - 상태 변경 모든 이벤트를 추적하므로, 모든 이벤트를 순서대로 재생하면 주문 상태를 복구할 수 있다.
- mmap 이벤트 저장소를 메시지 버스로 사용하는 이벤트 소싱 설계안을 채택한다.
    - 게이트웨이는 빠르고 간결한 인코딩을 위해 FIX를 SBE로 변환하여 전송한다.
    - 체결 엔진의 주문 관리자는 이벤트 저장소로부터 새로운 이벤트를 수신하면 처리 담당 CPU 코어로 주문을 전송한다.
    - 보고 서비스같은 다른 구성요소는 이벤트 저장소를 구독하고, 이벤트를 받을 때마다 적절히 처리한다.

## 고가용성

- 거래소 아키텍처의 SPOF를 식별하여 다중화한다.
    - 주문 관리자나 체결 엔진처럼 stateful한 서버는 사본 간 상태 데이터를 복사할 수 있어야 한다.
    - 이벤트 소싱 아키텍처는 결정론적 특성 때문에 상태 복구가 쉽고 정확하여 거래소에 적합하다.
- 장애 감지 및 백업 인스턴스로의 장애 조치 결정이 빨라야 한다.

## 결함 내성

- 운영 초기에는 수동으로 장애 복구 조치를 수행하고, 이후에는 자동 장애 감지 복구 프로세스를 도입한다.
    - **카오스 엔지니어링**을 통해 장애를 빠르게 식별한다.
    - **Raft 알고리즘**을 사용해 주 서버를 선출한다.
- **RTO**(복구 시간 목표)는 애플리케이션이 다운되어도 사업에 심각한 피해가 없는 시간의 최댓값이다.
    - 증권 거래소의 경우 2등급 RTO를 달성해야하며, 서비스의 자동 복구가 반드시 가능해야 한다.
    - 이를 위해 우선순위에 따라 서비스를 분류하고 최소 서비스 수준을 유지하기 위한 성능 저하 전략을 정의한다
- **RPO**(복구 지점 목표)는 비즈니스에 심각한 피해가 발생하기 전에 손실될 수 있는 데이터의 양을 의미한다.
    - 증권 거래소의 경우 데이터 손실을 용납할 수 없으므로 RPO가 0에 가깝다.
    - 데이터 사본을 여러 군데 두어 손실을 최소화한다.

## 체결 알고리즘

- FIFO + LMM(Lead Market Maker)
    - FIFO 큐보다 LMM에 먼저 일정 수량을 할당한다.

## 결정론

- 기능적 결정론
    - 시퀀서나 이벤트 소싱 아키텍처를 도입함으로써 이벤트를 동일한 순서로 재생하면 항상 같은 결과를 보장한다.
    - 이벤트 발생 시각은 중요하지 않고, 수서가 중요하다.
- 지연 시간 결정론
    - 각 거래처의 처리 시간이 거의 같다.
    - p99 지연 시간이 낮다는 것은 거래소가 거의 모든 거래에 안정적인 성능을 제공한다는 뜻이다.
    - 지연 시간 변동 폭이 커지면 원인을 조사해야 한다.
        - 자바의 경우 safe points가 원인인 경우가 많다.

## 시장 데이터 게시 서비스 최적화

- 링 버퍼를 사용한다.
    - 생산자는 계속 데이터를 넣고, 하나 이상의 소비자는 데이터를 꺼낸다.
    - 링 버퍼의 공간은 사전에 할당되므로 객체를 새성하거나 삭제하는 연산은 필요 없다.
    - 이 데이터 구조는 락을 사용하지 않는다.

## 시장 데이터의 공정한 배포

- 모든 수신자가 동시에 시장 데이터를 받을 수 있도록 보장하는 것이 중요하다.
    - 안정적 UDP를 사용하는 **멀티캐스트**는 한 번에 많은 참가자에게 업데이트를 브로드캐스트하기 좋은 솔루션이다.
    - 무작위 순서로 데이터를 주는 방법도 있다.

## 코로케이션

- 헤지 펀드 또는 브로커의 서버를 거래소와 같은 데이터 센터에 둘 수 있도록 하는 코로케이션 서비스를 제공한다.
- 체결 엔진에 주문을 넣는 지연 시간은 기본적으로 전송 경로 길이에 비례한다.
- 코로케이션 서비스가 공정성을 훼손한다고 보지는 않는다. (유료 VIP 서비스..? 🤔)

## 네트워크 보안

- 거래소는 일반적으로 몇 가지 인터페이스를 공개하고 있으므로 DDoS 공격에 대응할 수 있도록 하는 게 중요하다.
    - 공개 서비스와 데이터를 비공개 서비스에서 분리한다.
    - 읽기 전용 사본을 여러 개 만들어 문제를 격리한다.
    - 자주 업데이트 되지 않는 데이터는 캐싱한다.
    - URL을 강화한다.
    - safelist/blocklist 매커니즘을 사용한다.
    - 처리율 제한 기능을 활용한다.

# 4단계. 마무리

- 이상적인 배포 모델은 모든 것을 하나의 거대한 서버 또는 단일 프로세스에 배치하는 것이다.
    - 지금까지 쪼개고 쪼개기만 하다가 뭔가 신기하다.
- LGTM 🚀
