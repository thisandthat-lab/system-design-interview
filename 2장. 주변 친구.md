# 2장_주변 친구

- 앱 사용자 중 본인의 위치 정보 접근 권한을 허락한 사용자에 한해 인근 친구 목록을 보여주는 시스템
- 주변 친구 위치는 유동적이라는 점에서 1장 근접성 서비스와 차이가 있다.

# 1단계. 문제 이해 및 설계 범위 확정

## 기능 요구사항

- **사용자는 모바일 앱에서 주변 친구를 확인할 수 있다.**
    - 해당 친구까지의 거리, 마지막 갱신 시각(timestamp) 표시
    - 몇 초마다 한 번씩 갱신되어야 함
- ‘주변에 있다’의 기준 → 직선거리로 5mile (사용자가 직접 설정 가능)
- 사용자의 이동 히스토리 보관 (추후에 ML 등 다양한 용도로 사용)
- 친구가 10분 이상 비활성화 상태면 주변 친구 목록에서 삭제
- GDPR, CCPA 등 사생활 데이터 보호법은 고려하지 않음

## 비기능 요구사항

- **낮은 지연시간**: 친구의 위치 변화가 반영되는 데 오랜 시간이 걸리지 않아야 한다.
- **안정성**
- **결과적 일관성**

## 개략적 규모 추정

- 주변 친구는 5마일(8km) 반경 이내
- 친구 위치 정보는 30초 주기로 갱신 (사람이 걷는 속도 고려)
- DAU는 1억명으로 가정
- 동시 접속 사용자는 DAU는 10%, 즉 천만명으로 가정
- 평균적으로 한 사용자는 400명의 친구를 갖는다고 가정

→ **QPS = 천만명 / 30초 = ~334,000**

# 2단계. 개략적 설계안 제시 및 동의 구하기

## 개략적 설계안

- **공용 백엔드**
    - 단말과 단말 간의 연결이 아닌, 공용 백엔드와의 통신으로 데이터를 주고받는다.
    - 공용 백엔드의 역할
        - 모든 활성 상태 사용자의 위치 변화 내역 수신
        - 위치 변화 내역을 친구들의 단말로 전달
    - 동시 접속 사용자가 천만명인 시스템에서 사용하기는 한계가 있는 구조이다.

## 설계안

### 로드밸런서

- API 서버(stateless)와 웹소켓 서버(stateful) 서버 앞단에서 트래픽을 서버들에 배분하는 역할

### RESTful API 서버

- 사용자 DB에 접근하여 사용자 관리, 친구 관리, 인증 및 기타 기능 요청에 대한 응답을 제공하는 stateless 서버

### 웹소켓 서버

- 각 클라이언트는 웹소켓 연결을 지속적으로 유지한다.
- 친구 위치 정보 변경이 웹소켓을 통해 전달된다.

### 레디스 위치 정보 캐시

- 활성 상태 사용자의 가장 최근 위치 정보를 캐시한다.
- TTL이 지나면 해당 사용자는 비활성화 상태로 바뀌고, 캐시 또한 삭제된다.

### 사용자 데이터베이스

- 사용자 데이터 및 사용자의 친구 관계 정보를 저장한다.

### 위치 이동 이력 데이터베이스

- 사용자의 위치 변동 이력을 보관한다.

### 레디스 Pub/Sub 서버

- 레디스 Pub/Sub은 초경량 메시지 버스이다. (새로운 채널 생성은 아주 값싼 연산, GB급 메모리 제공)
    - 사용자들이 Redis 채널로 메시지를 Publish한다.
    - 해당 채널의 Subscriber들은 메시지를 받는다.
- **웹소켓 서버를 통해 수신한 특정 사용자의 위치 정보 변경 이벤트는 해당 사용자에게 배정된 Pub/Sub 채널에 발행한다.**
    - 해당 사용자의 친구 각각과 연결된 웹소켓 연결 핸들러는 해당 채널의 구독자로 설정되어 있다.
    - 따라서 특정 사용자의 위치가 바뀌면 해당 사용자의 모든 친구의 웹소켓 연결 핸들러가 호출된다.

### 주기적 위치 갱신

- **위치가 변경되었다!!**는 사실 전송: 클라이언트 →  LB → 웹소켓 서버
- 웹소켓 서버 (아래 3개의 단계가 병렬로 수행된다.)
    - 이벤트를 위치 이동 이력 DB에 저장한다.
    - 새 위치를 위치 정보 캐시에 보관하고, 웹소켓 연결 핸들러 안의 변수에 해당 위치를 반영한다.
    - Redis Pub/Sub 서버의 해당 사용자 채널에 새 위치를 발행한다.
- Redis Pub/Sub 채널에 발행된 새로운 위치 변경 이벤트는 모든 구독자(웹소켓 이벤트 핸들러)에게 broadcast 된다.
    - 그 결과 각 구독자의 웹소켓 연결 핸들러는 친구의 위치 변경 이벤트를 수신하게 된다.
- 메시지를 받은 웹소켓 서버는 새 위치를 보낸 사용자와 메시지를 받은 사용자 사이의 거리를 새로 계산한다.
    - 계산된 거리가 검색 반경을 넘지 않는다면, timestamp를 구독자의 클라이언트 앱으로 전송한다.
    - 계산된 거리가 검색 반경을 넘는다면 timestamp를 보내지 않는다. (갱신되지 않음)

## API 설계

- 웹소켓
    - 서버 API
        - 주기적인 위치 정보 갱신(request: 위도, 경도, 시각 정보 / response: none)
        - 웹소켓 초기화(request: 위도, 경도, 시각 정보 / response: 친구들의 위치 데이터)
    - 클라이언트 API
        - 클라이언트가 갱신된 친구 위치를 수신하는 데 사용할 API(request: 친구 위치 데이터, 변경된 timestamp)
        - 새 친구 구독(request: 친구 ID / response: 해당 친구의 가장 최근 위도, 경도, 시각 정보)
        - 구독 해지(request: 친구 ID / response: none)
- API 서버
    - 친구 추가/삭제 및 사용자 정보 갱신 등

## 데이터 모델

### 위치 정보 캐시

- Redis에 `사용자ID-{위도, 경도, 시각}` key-value 쌍을 저장한다.
- DB가 아닌 Redis(캐시 용도)에 저장하는 이유는?
    - 사용자의 현재 위치(일시적인 데이터)만 저장하면 된다. (영속성이 보장되지 않아도 됨)
    - 레디스는 읽기 및 쓰기 연산 속도가 빠르고(메모리에 저장되므로), TTL을 제공하므로 데이터 관리가 용이하다.

### 위치 이동 이력 데이터베이스

- 사용자ID, 위도, 경도, timestamp를 저장한다.
- 막대한 쓰기 연산 부하를 감당할 수 있고, Scale out 가능한 DB가 필요하다. → **카산드라**가 적합
- RDB도 사용할 수는 있으나, 샤딩이 필요하다.

# 3단계. 상세 설계

## 중요 구성요소별 규모 확장성

### API 서버

- stateless 서버이므로 늘 하던대로 CPU 사용률, 부하, I/O 상태에 따라 오토 스케일링 하면 된다.

### 웹소켓 서버

- 사용률에 따라 오토 스케일링 할 수 있지만, stateful한 서버이므로 sacle out 시에는 주의해야 한다.
    - 노드 제거 전 기존 연결이 종료되도록 해야 한다.
        - LB가 인식하는 노드 상태를 draining(연결 종료 중)으로 변경 → LB에서 새로운 연결을 맺지 않음
        - 그 후 모든 연결이 종료되면(혹은 충분한 시간이 흐르면) 서버 제거

### 클라이언트 초기화

- 모바일 클라이언트가 기동되면 웹소켓 클러스터 내 서버 가운데 하나와 지속성 웹소켓 연결을 맺는다.
- 웹소켓 연결이 초기화되면 클라이언트는 웹소켓에 사용자의 위치 정보를 전송하고, 웹소켓은 아래 작업을 수행한다.
    - 위치 정보 캐시에 보관된 사용자의 위치 갱신 및 웹소켓 연결 핸들러 내의 변수에 저장
    - 사용자 DB에서 사용자의 모든 친구 조회
    - 위치 정보 캐시에 배치 요청을 보내 모든 친구의 위치를 한 번에 조회 (TTL 만료된 비활성 친구는 목록에 없음)
    - 친구 위치와 사용자의 위치 정보 캐시로 거리를 계산하고, 검색 반경 이내이면 상세 정보를 클라이언트ㅔ 반환
    - 각 친구의 레디스 서버 Pub/Sub 채널 구독
    - 사용자의 현재 위치를 레디스 Pub/Sub 채널을 통해 모든 친구에게 전송

### 사용자 데이터베이스

- 사용자 상세 정보, 친구 관계 테이블이 필요하며 사용자 ID를 기준으로 샤딩한다.

### 위치 정보 캐시

- 각 항목에 TTL을 적용하므로, 최대 메모리 사용량은 일정 한도 아래로 유지된다.
- 사용자 ID를 기준으로 여러 서버에 샤딩한다.
- 가용성을 높이기 위해 각 샤드에 보관하는 위치 정보를 standby 노드에 복제해두고, primary 노드 장애 시 전환한다.

### 레디스 펍/섭 서버

- 채널 하나를 유지하기 위해서는 구독자 관계 추적을 위한 **해시 테이블**과 **연결 리스트**가 필요하다. (소량의 메모리 사용)
- 채널의 변경이 없으면 CPU 자원을 전혀 사용하지 않는다.
- 설계
    - 모든 사용자는 채널 하나를 가진다.
    - 앱 초기화 시 모든 친구의 채널을 구독한다. (활성/비활성 상태에 따라 채널 구독/구독 취소하지 않음)
    
    → 더 많은 메모리를 사용하게 되지만, 메모리가 병목이 될 가능성은 낮고 아키텍처는 단순해진다. (trade-off)
    

### 얼마나 많은 레디스 펍/섭 서버가 필요한가?

- 메모리 사용량
    - 모든 사용자에게 채널 하나씩을 할당한다. → 필요한 채널 수는 **1억**
    - 한 사용자의 활성 친구 중 100명이 주변 친구 기능을 사용한다고 가정, 
    구독자 한 명을 추적하기 위해 내부 해시 테이블과 연결 리스트에 20바이트 상당의 포인터를 저장해야 한다고 가정
        
        → 모든 채널을 저장하기 위해 필요한 메모리는 1억 * 20바이트 * 100명의 친구 = **200GB**
        
    - 100GB 메모리의 레디스 펍/섭 서버를 사용하는 경우 → 필요한 서버는 **2대**
- CPU 사용량
    - 펍/섭 서버가 구독자에게 전송해야 하는 위치 정보 업데이트 양 → 초당 1400만 건
    - 서버 한 대로 감당 가능한 구독자 수가 10만이라고 가정 → 필요한 레디스 서버 수는 1400만 / 10만 = **140대**

→ 레디스 펍/섭 서버의 병목은 메모리가 아니라 **CPU 사용량**이다.

→ 우리가 원하는 규모를 감당하려면 **분산 레디스 펍/섭 클러스터**가 필요하다.

### 분산 레디스 펍/섭 서버 클러스터

- 서비스 탐색 컴포넌트(etcd, Zookeeper 등)를 도입하여 문제를 풀어본다.
    - **가용 서버 목록을 유지하는 기능 및 해당 목록을 갱신하는 데 필요한 UI 또는 API**
        - 서비스 탐색 소프트웨어는 설정 데이터를 보관하기 위한 소규모의 키-값 저장소이다.
    - **클라이언트로 하여금 값에 명시된 레디스 펍/섭 서버에서 발생한 변경 내역을 구독할 수 있도록 하는 기능**
- 동작 과정
    - 키-값에 매달린 값에는 활성 상태의 모든 레디스 펍/섭 서버로 구성된 해시링을 보관한다. ex) 채널 2는 1번 서버
    - 웹소켓 서버는 해시 링을 참조하여 메시지를 발행할 레디스 펍/섭 서버를 선정한다.

### 레디스 펍/섭 서버 클러스터의 규모 확장 고려사항

- 레디스 펍/섭 서버 클러스터의 몇 가지 속성
    - 채널에 전송되는 메시지는 모든 구독자에게 전송되고 나면 바로 삭제된다. → 이 관점에서는 stateless
    - 채널에는 상태 정보가 보관되므로, 특정 채널을 담당하던 서버를 교체하려면 번거롭다. → 이 관점에서는 stateful
    
    → stateful 서버 클러스터로 취급하는 것이 바람직하다.
    
- 일반적으로는 혼잡 시간대 트래픽도 무리 없이 감당하도록 오버 프로비저닝한다.
- 불가피하게 규모를 늘려야 할 때는 아래 문제를 유의해야 한다.
    - 해시 링 위에서의 이동이 많아져 엄청난 재구독 이벤트가 한 번에 발생할 수 있다.
    - 재구독 요청을 처리하다 보면 클라이언트가 보내는 위치 정보 변경 메시지 처리가 누락될 위험이 있다.
    - 순간적인 부하로 인해 서비스의 상태가 불안정해질 수 있다.

### 운영 고려사항

- 펍/섭 장애가 발생하면 소프트웨어는 온콜 엔지니어에게 alert을 발송한다.
- 엔지니어는 장애가 발생한 노드를 대기 중인 노드와 교체한다.

## 친구 추가/삭제

- 새로운 친구가 추가되면 웹소켓 서버로 새 친구의 채널 구독 메시지를 보내는 콜백을 등록한다.
- 새로운 친구가 삭제되면 채널 구독 취소 메시지를 보내는 콜백을 등록한다.

## 친구가 많은 사용자

- 수천 명의 친구를 구독하는 데 필요한 펍/섭 구독 관계는 클러스터 내의 많은 웹소켓 서버에 분산되어 있다.
    
    → hotspot 문제는 발생하지 않는다.
    
- 많은 친구를 둔 사용자의 채널이 존재하는 펍/섭 서버의 경우 더 많은 부하가 몰릴 수 있다.
    
    → 클러스터 안에 100대 넘는 서버가 존재하고, 헤비 유저들의 채널이 모든 펍/섭 서버에 분산되므로 걱정하지 않아도 된다.
    

## 주변의 임의 사용자

- 위치 정보 공유에 동의한 주변 사용자를 무작위로 보여주도록 한다면 어떻게 할까?
    - 지오해시에 따라 구축된 펍/섭 채널 풀을 만들어둔다. (지오해시 격자마다 채널 하나씩 존재)
    - 해당 격자 내의 모든 사용자는 해당 격자에 할당된 채널을 구독한다.

## 레디스 펍/섭 외의 대안

- **Erlang**
    - 많이 사용하지 않는 언어
    - 얼랭은 고도로 분산된 병렬 어플리케이션을 위해 고안된 프로그래밍 언어이자 런타임 환경
    - 우리 시스템에서는
        - 웹소켓 → 얼랭
        - 레디스 펍/섭 클러스터 → 분산 얼랭 어플리케이션

# 4단계. 마무리

- 웹소켓: 클라이언트와 서버 사이의 실시간 통신을 지원한다.
- 레디스: 위치 데이터의 빠른 읽기/쓰기를 지원한다.
- 레디스 펍/섭: 한 사용자의 위치 정보 변경 내역을 모든 온라인 친구에게 전달한다.

---
💡 Redis Pub/Sub에서 메시지 발행 또는 수신에 실패할 경우 이를 감지하거나 재시도 할 수 있는 메커니즘
