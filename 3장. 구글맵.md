# 3장. 구글맵

# 1단계. 문제 이해 및 설계 범위 확정

## 기능 요구사항

- 주요 기능: **위치 갱신, 경로 안내, ETA(예상 도착 시간), 지도 표시** 등
- 도착 시간을 정확히 추정하기 위해 교통 상황을 고려해야 한다.
- 다양한 이동 방법을 지원해야 한다. (운전, 대중교통, 도보 등)

## 비기능 요구사항 및 제약사항

- 정확도
- 부드러운 경로 표시 (자연스러운 화면 표시 및 갱신)
- 최적의 데이터 및 배터리 사용량
- 당연한 가용성 및 규모 확장성 등

## 기본 개념 및 용어

### 측위 시스템

- 구 표면 상의 위치를 표현하는 체계
- 위경도기반 측위 시스템의 경우 최상단에는 북극, 최하단에는 남극이 있다.
- **위도(Lat)**: 주어진 위치가 얼마나 북쪽/남쪽인지를 의미한다.
- **경도(Lon)**: 주어진 위치가 얼마나 동쪽/서쪽인지를 의미한다.

### 3차원 위치의 2차원 변환

- **지도 투영법**: 3차원 구 위의 위치를 2차원 평면에 대응시키는 절차
- 도법은 다양하나, 거의 모든 투영법은 실제 지형의 기하학적 특성을 왜곡한다.
- 구글 맵은 웹 메르카토르 도법을 택하고 있다.

### 지오코딩

- 주소를 지리적 측위 시스템의 좌표로 변환하는 프로세스
- **인터폴레이션**: 지오코딩을 수행하는 한 가지 방법으로서, GIS같은 다양한 시스템이 제공하는 데이터를 결합한다.
- **GIS**: 도로망을 지리적 좌표 공간에 대응시키는 방법을 제공하는 시스템 중 하나이다.

### 지오해싱

- 지도 위 특정 영역을 영문자와 숫자로 구성된 짧은 문자열에 대응시키는 인코딩 체계
- 2차원의 평면 공간으로 표현된 지리적 영역 위의 격자를 더 작은 격자로 재귀적으로 분할해나간다.

### 지도 표시

- 지도 전부를 하나의 이미지로 표시하는 대신 작은 타일로 쪼개어 표시한다.
- 클라이언트는 사용자가 보려는 영역과 관계된 타일만 다운받아 모자이크처럼 이어 붙인 다음 화면에 뿌린다.
- 지도 확대/축소 수준에 따라 다른 종류의 타일을 준비한다.

### 경로 안내 알고리즘을 위한 도로 데이터 처리

- 대부분의 라우팅 알고리즘은 Djikstra 알고리즘이나 A* 경로 탐색 알고리즘의 변종이다.
- 모든 경로 탐색 알고리즘은 교차로를 node로, 도로는 EDGE로 표현하는 그래프 자료 구조를 가정한다.
- 세계를 작은 격자로 나누고, 각 격자 안의 도로망을 노드와 선으로 구성된 그래프 자료 구조로 변환한다.
- 각 타일은 도로로 연결된 다른 타일에 대한 참조를 유지한다.

### 계층적 경로 안내 타일

- 경로 안내가 효과적으로 동작하려면 필요한 수준의 구체성을 갖춘 도로 데이터가 필요하다.
- 구체성 정도를 상, 중, 하로 구분하여 세 가지 종류의 경로 안내 타일을 준비한다.
    - 상: 지방도
    - 중: 관할구
    - 하: 도시와 주를 연결하는 고속도로

## 개략적 규모 추정

### 저장소 사용량

- 세계 지도, 메타데이터, 도로 정보 데이터를 저장해야 한다.
- 도로 정보
    - 외부에서 받은 수 TB 용량의 도로 데이터를 저장한다.
- 세계 지도
    - 지원하는 확대 수준별로 지도 타일이 한 벌씩 필요하다.
        
        → **지도를 최대한 확대하여 보는 데 필요한 타일 개수가 필요함**
        
    - 지도를 확대할 때마다 하나의 타일이 4개로 쪼개진다고 가정, 최대 21회까지 확대할 수 있다고 가정
        
        → 4.4조개의 타일 * 한 장당 100KB = **440PB**
        
    - 지구 표면 가운데 90%는 인간이 살지 않는 자연임을 고려하여 8~90% 절감 가능 → **44PB~88PB**

### 서버 대역폭

- 경로 안내 요청, 위치 갱신 요청을 처리해야 한다.
- DAU 10억, 각 사용자가 경로 안내 기능을 평균적으로 주당 35분 사용한다고 가정
    
    → 주당 350억 분 = **하루 50억 분**
    
- GPS 위치 변경 내역은 15초마다 한 번씩 서버로 보낸다고 가정
    
    → **QPS** = 하루 300만건의 요청 / 15초 = **20만**
    
- 최대 QPS는 평균치의 5배로 가정
    
    → **최대 QPS = 100만**
    

# 2단계. 개략적 설계안 제시 및 동의 구하기

## 개략적 설계안

### 위치 서비스

- 사용자의 위치를 기록하는 역할을 담당한다.
- 대략적인 아키텍처는 **모바일 클라이언트 → LB → 위치 서비스 → 사용자 위치 DB** 이렇게 구성된다.
- 클라이언트가 t초마다 자기 위치를 전송한다고 가정한다.
    - 데이터 스트림을 활용하여 시스템을 점차 개선할 수 있다.
    - 클라이언트가 보내는 위치 정보가 거의 실시간 정보에 가까우므로 ETA를 좀 더 정확하게 산출할 수 있다.
- 위치 이력을 클라이언트에 버퍼링 해 두었다가, 일괄 요청하면 전송 빈도를 줄일 수 있다.
- 그럼에도 **많은 쓰기 요청**을 처리해야 하기 때문에 Cassandra같은 DB가 필요하다.
- Kafka같은 스트림 처리 엔진을 활용하여 위치 데이터를 로깅한다.
- HTTP + keep-alive 옵션을 사용하여 통신한다.

### 경로 안내 서비스

- A → B로 가는 합리적으로 빠른 경로를 찾는 역할을 담당한다.
- 계산된 경로가 최단 시간 경로일 필요는 없으나, 정확도는 반드시 보장되어야 한다.
- API 요청
    - request: 출발지, 목적지
    - response: 거리, 소요시간, 출발지 위경도, 목적지 위경도, 교통수단 등
- 경로 재탐색이나 교통 상황 변화 문제는 상세 설계에서 고려해본다.

### 지도 표시

- 클라이언트의 위치 및 클라이언트가 보는 확대 수준에 따라 필요한 타일을 서버에서 가져오는 게 바람직하다.
- 클라이언트는 언제 지도 타일을 서버에서 가져오는 게 좋을까?
    - **클라이언트의 위치와 확대 수준에 근거하여 필요한 지도 타일을 on-demand로 생성한다.**
        - 매 요청 시마다 모든 지도 타일을 동적으로 만들어야 하는 서버에 부하가 생긴다.
        - 캐시를 활용하기 어렵다.
    - **확대 수준별로 미리 만들어 둔 지도 타일을 클라이언트에 전달한다.**
        - 미리 만들어 둔 정적 이미지를 CDN을 통해 서빙할 수 있어 서버 부하도 덜고 빠르다.
        - 클라이언트에도 캐시를 두면 데이터 사용량을 많이 줄일 수 있을 것이다.
    - 데이터 사용량 추정
        - 사용자가 30km/h로 이동중이며, 한 타일이 200m*200m 영역을 표현하도록 확대한다고 가정
            
            → 1km*1km 영역을 표현하려면 25장의 이미지 필요
            
            → 25장 * 100KB = 2.5MB
            
            → 30 * 2.5MB = 시간당 75MB = **분당 1.25MB**의 데이터 소진
            
    - CDN 데이터 사용량 추정
        - 매일 50억 분의 경로 안내 처리
            
            → 50억 * 1.25MB = 6.25PB/일
            
            → **초당 전송해야 하는 지도 데이터의 양** = 6.25PB / (10^5초 / 하루) = **62,500MB**
            
        - CDN 사용 시 전 세계에 200대의 POP이 있다고 가정
            
            → POP 당 처리해야 하는 트래픽 = **62,500 / 200 MB**
            
- 클라이언트는 CDN에서 지도 타일을 가져올 URL을 어떻게 결정할까?
    - 위경도로 표현된 클라이언트의 위치와 지도 확대 수준으로 지오해시를 계산하여 지오해시로 찾는다. (서버에서 구현)
    - 또는 위/경도 및 확대 수준을 타일 URL로 변환하는 알고리즘 구현을 별도 서비스로 분리한다.
- 아키텍처는 **모바일 사용자 → LB → 지도 타일 서비스(타일 URL 생성) / CDN** 으로 구성된다.
    - 클라이언트가 타일 URL을 요청하면 서버에서 타일 URL을 계산해서 클라이언트에 반환한다.
    - 클라이언트는 해당 타일을 CDN을 통해 다운로드한다.

# 3단계. 상세 설계

## 데이터 모델

### 경로 안내 타일

- 필요한 도로 데이터(원천 데이터)는?
    - 외부 사업자나 기관이 제공한 것을 이용해야 함
    - 데이터 용량이 수 TB에 달하며, 방대한 양의 도로 및 메타데이터로 구성됨
    - 그래프 자료 구조 형태로 가공되어 있지 않으므로, 주어진 상태 그대로 경로 안내 알고리즘의 입력으로 활용할 수 없음
    
    → **경로 안내 타일 처리 서비스(오프라인 데이터 가공 파이프라인)**을 주기적으로 실행하여 경로 안내 타일로 변환한다.
    
- 경로 안내 타일 처리 서비스에서 가공된 결과 타일은 어디에 저장되어야 할까?
    - 그래프는 보통 메모리에 인접 리스트 형태로 보관하는 것이 일반적이지만, 타일 데이터는 메모리에 두기에 양이 많음
    - 그래프의 노드와 선을 DB 레코드에 저장하는 것은 비용이 많이 들고 비효율적임
    
    → **S3같은 객체 저장소**에 파일(**인접 리스트를 바이너리 형태로 직렬화**)을 보관하고, 캐싱하여 사용한다.
    
    → 이 때 **지오해시 기준으로 분류**해두면 위도와 경도가 주어졌을 때 타일을 신속하게 찾을 수 있다.
    

### 사용자 위치 데이터

- 사용자 위치 데이터는 어디에 쓰일까?
    - 도로 데이터 및 경로 안내 타일 갱신
    - 실시간 교통 상황 데이터나 교통 상황 이력 데이터베이스 구축
    - 데이터 스트림 프로세싱 서비스는 이 위치 데이터를 처리하여 지도 데이터를 갱신
    
    → **쓰기 연산**에 특화되어 있고, 수평적 규모 확장이 가능한 DB를 선택해야 한다. ex) 카산드라
    

### 지오코딩 데이터베이스

- 주소를 위도/경도 쌍으로 변환하는 정보를 보관한다.
- **읽기 연산**은 빈번한데 반해 쓰기 연산은 드물게 발생한다.
    
    → Redis처럼 빠른 읽기 연산을 제공하는 키-값 저장소가 적당하다.
    

### 미리 만들어 둔 지도 이미지

- 이미지는 지도 확대 수준별로 미리 만들어두고 CDN을 통해 전송한다.

## 서비스

### 위치 서비스

- 초당 백만 건의 위치 정보 업데이트가 발생하므로 쓰기 연산 지원에 탁월한 DB가 필요하다.
    
    → NoSQL 키-값 데이터베이스 또는 컬럼 중심 데이터베이스가 적합하다.
    
- 사용자 위치는 계속 변화하며, 이전 정보는 바로 무용해진다.
    
    → 데이터 일관성보다 가용성이 더 중요하다.
    
    → CAP 정리 중 A(가용성)와 P(분할 내성)를 만족시키도록 한다.
    
- 데이터베이스 키로는 (user_id, timestamp) 조합을 사용하며, 값으로는 위도/경도 쌍을 저장한다.
    - user_id는 파티션 키
    - timestamp는 클러스터링 키
    - 같은 파티션 키를 갖는 데이터는 함께 저장되며, 클러스터링 키 값으로 정렬된다.

### 사용자 위치 데이터를 용도에 맞게 사용하기 위해

- 카프카와 같은 메시지 큐에 로깅하고, 개별 서비스에서 데이터 스트림을 용도에 맞게 활용한다.
    - 실시간 교통 상황 서비스, 개인화를 위한 ML 서비스, 분석 서비스 등에서 이벤트를 컨슈밍하여 처리한다.

## 지도 표시

### 지도 타일 사전 계산

- 확대 수준을 1단계 늘릴 때마다 해상도는 4배씩 늘어난다.
- 화면에 한 번에 표시 가능한 지도 타일 개수는 달라지지 않는다.
- **WebGL 기술(벡터)**을 사용하여 최적화한다.
    - 네트워크로 이미지 전송이 아닌 경로와 폴리곤 등의 벡터 정보를 보내 클라이언트가 지도를 그린다.
    - 벡터는 이미지보다 압축률이 높아 네트워크 대역폭을 많이 아낄 수 있다.
    - 매끄러운 확대 경험을 제공할 수 있다.

## 경로 안내 서비스

- 아키텍처 흐름
    - 유저가 경로 안내 서비스를 호출한다.
    - 경로 안내 서비스가 지오코딩 서비스를 호출한 결과로 경로 계획 서비스를 호출한다.
    - 경로 계획 서비스는 순위 결정 서비스, 최단 경로 서비스, 예상 도착 서비스를 각각 호출하여 결과를 조합한다.

### 지오코딩 서비스

- 주소를 request로 받아 위경도 쌍을 response로 내려주는 서비스이다.
- 경로 안내 서비스는 지오코딩 서비스를 통해 위경도 쌍을 받고 다른 서비스 호출에 이용한다.

### 경로 계획 서비스

- 현재 교통 상황과 도로 상태를 반영하여 최적화 된 경로를 제안하는 서비스이다.
- 타 서비스들과 통신하여 결과를 만들 수 있다.

### 최단 경로 서비스

- 출발지, 목적지, 위도/경도를 request로 받아 k개 최단 경로를 response로 내려주는 서비스이다.
- 교통 상황과 도로 상태는 반영하지 않으므로, 도로망 그래프는 캐시해두고 사용한다.

### 예상 도착 시간 서비스

- 머신러닝을 통해 현재 교통 상황 및 과거 이력에 근거하여 예상 도착 시간을 계산하는 서비스이다.
- 경로 계획 서비스가 최단 경로 서비스를 통해 최단 경로 목록을 수신하면 예상 도착 시간 서비스를 호출하게 된다.

### 순위 결정 서비스

- 경로 계획 서비스가 ETA 예상치를 구하고 나면 순위 결정 서비스에 전달하여 사용자가 정의한 필터링을 적용하게 된다.
    
    ex) 유료 도로 제외, 고속도로 제외 등
    
- 필터링 된 경로를 소요 시간 순으로 정렬하여 최단 시간 경로 k개를 경로 안내 서비스에게 반환한다.

### 중요 정보 갱신 서비스들

- 카프카의 위치 데이터 스트림을 구독하고 있다가 중요 데이터를 비동기적으로 업데이트하여 최신 상태를 유지한다.
    - 경로 안내 타일 처리 서비스
    - 실시간 교통 상황 서비스

### 적응형 ETA와 경로 변경

- 본 설계안에서는 적응형 ETA와 경로 변경을 허용하지 않는다.
- 자세한 내용은 106~107p 알고리즘을 참고하세요..

### 전송 프로토콜

- 데이터를 모바일 클라이언트에 전송할 안정적인 프로토콜
    - 모바일 푸시 알림 → 메시지 크기가 매우 제한적이고, 웹에서 지원이 안됨
    - 롱 폴링
    - **웹소켓** → 서버 부담이 적어서 롱 폴링 방식보다는 권장됨, 양방향 통신을 지원함
    - SSE(Server-Sent Events) → Server to Client 단방향 통신만 지원됨

# 4단계. 마무리

- 확장할만한 기능
    - 중간 경유지 설정 기능
- 고생했다!

---
💡 경로 계획 서비스가 응답을 만들기 위해서는 여러 서비스를 호출하고 매쉬업해서 데이터를 내려주어야 하는 것 같아서 서버 작업량이 상당해보이는데, 어떤 포인트들에서 성능을 개선해 볼 수 있을까?
