# 1장. 근접성 서비스

- 현재 위치에서 가까운 시설 찾기
    - ex) 주변의 평점 높은 식당 찾기, 가까운 n개 주유소 검색 등

# 1단계. 문제 이해 및 설계 범위 확정

## 기능 요구사항

- **사용자의 위치(경도와 위도 쌍)와 검색 반경 정보에 매치되는 사업장 목록을 반환한다.**
    - 최대 허용 반경은 20km
    - UI에서 0.5km, 1km, 2km, 5km, 20km 선택 가능
    - 사용자의 이동에 따라 실시간으로 화면이 갱신될 필요는 없음
- **사업장 소유주가 사업장 정보를 시스템에 CUD한다.**
    - 사업장 정보는 실시간으로 반영될 필요는 없음 (다음날까지 반영되어야 함)
    - 사용자는 사업장의 상세 정보를 확인할 수 있어야 함

## 비기능 요구사항

- **낮은 latency**
- **데이터 보호**
    - 위치 기반 서비스(LBS) 설계 시 사용자의 정보를 보호할 방법을 고려해야 한다.
    - GDPR, CCPA와 같은 데이터 사생활 보호 법안을 준수해야 한다.
- **고가용성 및 규모 확장성**
    - 인구 밀집 지역에서 트래픽이 급증해도 감당할 수 있도록 설계해야 한다.

## 개략적 규모 추정

- DAU 1억, 등록된 사업장 수가 2억이라고 가정했을 때의 QPS 계산
    - 1일 = 24시간 * 60분 * 60초 = 86,400초 → 대략 `10^5`로 가정
    - 한 사용자가 하루 5회 검색을 시도한다고 가정했을 때 QPS = (1억 * 5회) / 10^5 = `5,000`

# 2단계. 개략적 설계안 제시 및 동의 구하기

## API 설계

- **GET /v1/search/nearby** : 위경도와 검색반경을 받아 특정 검색 기준에 맞는 사업장 목록 반환
- **GET /v1/business/:id** : 특정 사업장의 상세 정보 반환
- **POST /v1/business** : 새로운 사업장 추가
- **PUT /v1/business/:id** : 사업장 상세 정보 갱신
- **DELETE /v1/business/:id** : 특정 사업장 정보 삭제

## 데이터 모델

- 읽기/쓰기 비율 고려
    - 읽기 연산 비중이 압도적으로 높다. (사업장 검색, 사업장 정보 확인)
    - 쓰기 연산 비중은 압도적으로 낮다.
    
    → 읽기 연산이 압도적인 시스템에는 RDB가 바람직할 수 있다.
    
- 데이터 스키마
    - business 테이블 : 사업장 상세 정보 저장
    - 지리적 위치 색인 테이블

## 개략적 설계

- LB에서 `/search/nearby`는 **LBS** 서버로, `/businesses/:id`는 **사업장 서비스**로 라우팅한다.
    - **Load Balancer**
        - 단일 DNS entry point를 지정하고 URL 경로를 분석하여 어느 서비스에 트래픽을 전달할 지 결정한다.
    - **LBS(위치 기반 서비스)**
        - 주어진 위치와 반경 정보를 이용해 주변 사업장을 검색한다.
        - 쓰기 요청 없이 읽기 요청만 빈번하게 발생한다.
        - QPS가 높고, 특정 시간대의 인구 밀집 지역일수록 더 심하다.
        - stateless 서비스이므로 Scale In/Out이 쉽다.
    - **사업장 서비스**
        - 사업장 소유주에 의한 사업장 정보 CUD가 이루어지며, QPS는 낮다.
        - 고객이 사업장 정보를 조회하며, 특정 시간대 QPS가 높아진다.
    - **DB Cluster**
        - primary-second DB 형태로 구성한다.
        - primary DB는 쓰기 요청을 처리하며, second 즉 replica DB는 읽기 요청을 처리한다.
        - 데이터는 primary에 기록된 다음 replica로 복사된다. (복제 지연 시간에 의해 잠시동안 차이가 있을 수 있다.)

### 사업장 서비스와 LBS의 규모 확장성

- 둘 다 stateless 서비스이므로 트래픽이 집중되는 시간대에는 자동으로 Scale Out, 유휴시간대에는 Scale In 하도록 한다.
- 서버가 클라우드에 존재한다면 여러 az에 서버를 두어 가용성을 높인다.

## 주변 사업장 검색 알고리즘

- 많은 회사들은 Geohash in Redis, PostGIS를 설치한 Postgresql을 사용한다.

### 방안1: 2차원 검색

- 주어진 반경으로 그린 원 안에 놓인 사업장을 검색하는 방법
- DB 쿼리로 테이블 전부를 읽어야 하므로 비효율적이다. (컬럼 인덱스도 크게 효율성을 높여주지 못한다.)
- 지리적 정보에 색인을 만드는 방법
    - 해시 기반 방안: **균등 격자**, **지오해시**, 카르테시안 계층 등
    - 트리 기반 방안: **쿼드트리**, **구글 S2**, R 트리 등
    
    → 지도를 작은 영역으로 분할하고 고속 검색이 가능하도록 색인을 만든다.
    

### 방안2: 균등 격자

- 지도를 작은 격자 또는 구획으로 나누는 단순한 접근법
- 하나의 격자는 여러 사업장을 담을 수 있고, 하나의 사업장은 한 격자에만 속한다.
- 균등한 격자로 나누면 데이터의 분포는 불균등하다는 단점이 있다.

### 방안3: 지오해시(Geohash) ⭐️

- 비트를 하나씩 늘려가며 재귀적으로 격자를 분할해 나가며 2차원의 위도 경도 데이터를 1차원의 문자열로 변환한다.
    - 전 세계를 자오선과 적도 기준 사분면으로 나눈다. (11, 01, 00, 10)
    - 각각의 격자를 또 다시 사분면으로 나눈다.
    - 이 때 경도와 위도 비트도 반복하여 표현한다. (11 11, 11 01, 11 00, 11 10)
    - 원하는 정밀도를 얻을 때까지 위 절차를 반복한다.
- 지오해시는 통상적으로 base32 표현법을 사용한다. ex) 9q9hvu, 919jhr 등
- 지오해시는 12단계의 정밀도를 가지고, 적당한 정밀도는 4~6이다.
    - 최적 정밀도는 구하려면 사용자 지정 반경으로 그린 원을 덮는 최소 크기 격자를 만드는 지오해시 길이를 구해야 한다.
- **격자 가장자리 관련 이슈**: 지오해시는 해시값의 공통 prefix가 긴 격자들이 서로 가깝게 놓여 있음을 보장한다.
    - 그 역은 참이 아니다.
    - 두 지점의 공통 prefix는 같지만 서로 다른 격자에 놓일 수 있다. → 인접한 모든 격자의 모든 사업장을 가져온다(O(1))
- **표시할 사업장이 충분하지 않을 경우**
    - 주어진 반경 내 사업장만 반환한다. → 사용자의 욕구를 충족하지 못할 수 있다.
    - 충분한 사업장을 얻을 때까지 지오해시 값의 마지막 비트를 삭제하면서 검색한다.

### 방안4: 쿼드트리 ⭐️

- 격자의 내용이 특정 기준을 만족할 때까지 2차원 공간을 재귀적으로 사분면 분할하는 데 사용되는 자료구조
- 쿼드트리는 메모리 안에 놓이는 자료 구조일 뿐, DB가 아니다.
    - 질의에 답하는 데 사용될 트리 구조를 메모리 안에 만드는 것이다.
- 쿼드트리 노드별 보관되는 데이터
    - 말단 노드: 좌상단과 우하단 꼭짓점 좌표(32byte), 격자 내부 사업장 ID 목록(ID당 8byte)
    - 내부 노드: 좌상단과 우하단 꼭짓점 좌표(32byte), 하위 노드 4개를 가리키는 포인터(32byte)
    
    → 쿼드트리 인덱스가 메모리를 많이 사용하지 않는다.
    
- 쿼드트리 운영 시 고려사항
    - 서버를 시작하는 순간에 트리를 구축하면 서버 시작 시간이 길어질 수 있다.
    - 서버를 동시에 배포하면 순간적으로 DB에 읽기 부하가 몰릴 수 있다.
    - 사업장 추가/삭제 시에는 트리를 점진적으로 갱신하고, 트래픽이 적은 새벽 시간대에 캐시를 일괄 갱신하도록 한다.
- 쿼드트리를 사용하면 인구 밀집 지역에는 작은 격자를, 그렇지 않은 지역에는 큰 격자를 사용하는 것이 가능해진다.

### 방안5: 구글 S2

- 메모리 기반이며, 지구를 **힐베르트 곡선**이라는 공간 채움 곡선을 사용하여 1차원 인덱싱하는 방안이다.
    - 힐베르트 곡선 상에서 인접한 두 지점은 1차원 공간 내에서도 인접한 위치에 있다.
    - 1차원 공간 내에서의 검색이 2차원 공간에서의 검색보다 훨씬 효율적이다.
- **지오펜스** 구현에 적합하다.
    - 지오펜스는 실세계 지리적 영역에 설정한 가상의 경계이다.
    - 동적으로 지정할 수도, 이미 존재하는 경계선들을 묶어 설정할 수도 있다.
    - 관심 있는 영역의 경계를 정한 다음 해당 경계를 벗어나면 사용자에게 알림을 보내는 등 풍부한 기능을 제공할 수 있다.
- **영역 지정 알고리즘**을 사용한다.
    - 지오해시처럼 고정밀도를 사용하면서 min level, max level, max cells 등을 유연하게 지정할 수 있다.

# 3단계. 상세 설계

## 데이터베이스의 규모 확장성

### 사업장 테이블

- 사업장 ID 기준으로 샤딩한다.

### 지리 정보 색인 테이블

- 지오해시 쿼드트리 중 지오해시를 사용한다고 가정한다.
    - 지오해시, 사업장ID를 각각 별도 row로 저장한다. (사업장 하나마다 하나의 row)
    - (지오해시, 사업장ID)를 복합키로 사용한다.
- 저장될 데이터의 양이 많지 않고, 읽기 부하에 대응하면 되므로 RO DB 복제본을 여러 대 두어 부하를 분산한다.

## 캐시

- 처리 부하가 읽기 중심이고 데이터 크기는 상대적으로 작아 질의문 처리 성능이 I/O에 좌우되지 않는다.
- 읽기 성능은 RO DB Scale Out으로 해결할 수 있다

### 캐시 키

- 사용자 위치 정보는 자주 변하고 부정확하므로 캐시 키로 부적절하다.
- 지오해시나 쿼드트리는 같은 격자 내 모든 사업장이 같은 해시 값을 만들 수 있기 때문에 캐시 키로 적절하다.

### 캐시 데이터 유형

- 지오해시-해당 격자 내 사업장 ID 목록, 사업장ID-사업장 정보 객체는 캐시에 보관하면 성능을 향상시킬 수 있다.

## 지역 및 가용성 구역

- 위치 기반 서비스를 여러 지역과 az에 설치했을 때의 기대 효과
    - 사용자와 시스템 간의 물리적 거리를 최소한으로 줄여 latency를 줄인다.
    - 트래픽을 인구에 따라 고르게 분산한다.
    - 그 지역의 사생활 보호법에 맞는 운영이 가능하다.

## 최종 설계도

- 사용자가 주변 반경 500미터 내 모든 식당 검색 요청을 보낸다. (`/search/nearby`)
- LB는 해당 요청을 LBS로 보낸다.
- LBS는 지오해시 길이를 계산한다. → 지오해시 길이 6
- LBS는 인접한 지오해시를 계산하여 목록에 추가한다.
- 지오해시 Redis에서 목록에 대응하는 모든 사업장 ID를 병렬로 추출한다.
- 사업장 정보 Redis에서 사업장의 상세 정보를 취득하고, 후처리 후 클라이언트에 반환한다.

# 4단계. 마무리

- LGTM🚀

---
💡 읽기 연산이 압도적인 시스템에 RDBMS가 바람직한 이유
- RDB는 디스크에 저장되는데 in-memory DB가 더 빠르지 않을까?
- 대표적인 in-memory DB가 Redis
- MySQL의 in-memory 모드 지원

💡 사업장 테이블을 사업장 ID 기준으로 샤딩하면 핫키문제가 발생할 수 있는 거 아닌가?
